# Workflow for Synthizer3d
# by Ambro86, adapted for cibuildwheel
name: Build Synthizer3d Wheels and Sdist

on:
  push: {}
  pull_request: {}

jobs:
  build_wheels:
    name: Build Wheels on ${{ matrix.os }} (${{ matrix.arch_label }}) # Changed matrix.arch to matrix.arch_label for clarity in name
    runs-on: ${{ matrix.os }}
    permissions:
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        # Define OS and a label for architecture for the job name
        # The actual architecture for cibuildwheel will be controlled by CIBW_ARCHS_*
        include:
          - os: ubuntu-latest
            arch_label: x64_aarch64 # Indicates intent to build both if possible
            cibw_archs: "x86_64 aarch64"
            vcpkg_triplet_map_x86_64: "x64-linux" # For primary arch
            vcpkg_triplet_map_aarch64: "aarch64-linux" # For secondary arch if vcpkg setup needs it per-arch
            is_linux: true
          - os: windows-latest
            arch_label: x86_amd64
            cibw_archs: "x86 AMD64"
            vcpkg_triplet_map_x86: "x86-windows"
            vcpkg_triplet_map_amd64: "x64-windows"
            is_windows: true
          - os: macos-13 # Intel runner
            arch_label: x64
            cibw_archs: "x86_64"
            vcpkg_triplet_map_x86_64: "x64-osx"
            is_macos: true
          - os: macos-14 # Apple Silicon runner (usually defaults to arm64)
            arch_label: arm64
            cibw_archs: "arm64"
            vcpkg_triplet_map_arm64: "arm64-osx"
            is_macos: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Run C/C++ code vendoring script
        run: python synthizer-c/vendor.py synthizer-vendored

      # Setup vcpkg. For Linux, CIBW_BEFORE_ALL might be better if different archs need different setups.
      # For now, we assume a primary vcpkg setup per job, CMAKE_PREFIX_PATH will be critical.
      - name: Determine vcpkg triplet for primary architecture
        id: vcpkg_triplet_primary
        shell: bash
        run: |
          TRIPLET=""
          if [ "${{ matrix.is_windows }}" == "true" ]; then
            # Default to AMD64 for Windows if building both, or specific if only one
            if [[ "${{ matrix.cibw_archs }}" == *"AMD64"* ]]; then
              TRIPLET="${{ matrix.vcpkg_triplet_map_amd64 }}"
            else
              TRIPLET="${{ matrix.vcpkg_triplet_map_x86 }}"
            fi
          elif [ "${{ matrix.is_linux }}" == "true" ]; then
             # Default to x86_64 for Linux
            TRIPLET="${{ matrix.vcpkg_triplet_map_x86_64 }}"
          elif [ "${{ matrix.is_macos }}" == "true" ]; then
            if [[ "${{ matrix.cibw_archs }}" == "x86_64"* ]]; then
              TRIPLET="${{ matrix.vcpkg_triplet_map_x86_64 }}"
            else
              TRIPLET="${{ matrix.vcpkg_triplet_map_arm64 }}"
            fi
          fi
          echo "PRIMARY_VCPKG_TRIPLET=$TRIPLET" >> $GITHUB_ENV
          echo "Determined PRIMARY_VCPKG_TRIPLET: $TRIPLET"

      - name: Set up vcpkg and dependencies
        uses: lukka/run-vcpkg@v11.6 # Specify a version
        with:
          vcpkgTriplet: ${{ env.PRIMARY_VCPKG_TRIPLET }}
          # vcpkgJsonGlob: 'vcpkg.json' # if your vcpkg.json is in the root

      - name: Install vcpkg packages
        shell: bash
        run: |
          echo "VCPKG_ROOT is $VCPKG_ROOT"
          echo "VCPKG_DEFAULT_TRIPLET (from lukka/run-vcpkg) is $VCPKG_DEFAULT_TRIPLET"
          echo "PRIMARY_VCPKG_TRIPLET (for this job) is ${{ env.PRIMARY_VCPKG_TRIPLET }}"
          if [ -z "$VCPKG_ROOT" ]; then
            echo "Error: VCPKG_ROOT is not set."
            exit 1
          fi
          # Ensure vcpkg.json is used or specify packages
          "$VCPKG_ROOT/vcpkg" install --triplet "$VCPKG_DEFAULT_TRIPLET" # Use the one lukka/run-vcpkg actually configured

          VCPKG_INSTALLED_DIR_FOR_JOB="$VCPKG_ROOT/installed/$VCPKG_DEFAULT_TRIPLET"
          echo "VCPKG_INSTALLED_DIR_PATH_FOR_CIBW=$VCPKG_INSTALLED_DIR_FOR_JOB" >> $GITHUB_ENV
          echo "Determined VCPKG_INSTALLED_DIR_PATH_FOR_CIBW: $VCPKG_INSTALLED_DIR_FOR_JOB"

      - name: Build wheels with cibuildwheel
        uses: pypa/cibuildwheel@v2.19.1
        env:
          # --- VCPKG Environment for cibuildwheel ---
          # This passes the VCPKG_INSTALLED_DIR_PATH_FOR_CIBW (determined above)
          # into the build environments that cibuildwheel creates.
          CIBW_ENVIRONMENT_WINDOWS: >
            CMAKE_PREFIX_PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}
            PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}\\bin;${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}\\tools\\${{ env.PRIMARY_VCPKG_TRIPLET }};${{ env.PATH }}
          CIBW_ENVIRONMENT_LINUX: >
            CMAKE_PREFIX_PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}
            LD_LIBRARY_PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/lib:$LD_LIBRARY_PATH
            PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/bin:${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/tools/${{ env.PRIMARY_VCPKG_TRIPLET }}:${{ env.PATH }}
          CIBW_ENVIRONMENT_MACOS: >
            CMAKE_PREFIX_PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}
            DYLD_LIBRARY_PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/lib:$DYLD_LIBRARY_PATH
            PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/bin:${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/tools/${{ env.PRIMARY_VCPKG_TRIPLET }}:${{ env.PATH }}

          # --- Python Versions & Architectures ---
          CIBW_BUILD: "cp38-* cp39-* cp310-* cp311-* cp312-* cp313-*"
          CIBW_ARCHS_WINDOWS: ${{ matrix.cibw_archs }}
          CIBW_ARCHS_LINUX: ${{ matrix.cibw_archs }}
          CIBW_ARCHS_MACOS: ${{ matrix.cibw_archs }}

          # --- Linux manylinux image ---
          # If default (manylinux2014) is too old for vcpkg (e.g. needs newer GCC)
          CIBW_MANYLINUX_X86_64_IMAGE: manylinux_2_28
          CIBW_MANYLINUX_AARCH64_IMAGE: manylinux_2_28
          # You might need to install build-essential, curl etc. in CIBW_BEFORE_ALL_LINUX
          # if the manylinux image doesn't have them for vcpkg's own build process.
          CIBW_BEFORE_ALL_LINUX: >
            yum install -y patchelf openssl-devel zlib-devel && # Example for manylinux_2_28 (CentOS based)
            rm -rf /var/cache/yum

          # --- Build & Repair ---
          CIBW_BUILD_VERBOSITY: 1 # 0, 1, 2, 3

          CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: >-
            delvewheel repair --add-path "${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}\bin;${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}\lib" -w {dest_dir} {wheel}
          CIBW_PIP_PACKAGES_WINDOWS: delvewheel

          CIBW_PIP_PACKAGES_MACOS: delocate


      - name: Upload Python Wheel Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-wheels-${{ matrix.os }}-${{ matrix.arch_label }} # Use arch_label
          path: ./wheelhouse/*.whl

  build_sdist:
    name: Build Python sdist
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python (for sdist)
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Run C/C++ code vendoring script
        run: python synthizer-c/vendor.py synthizer-vendored

      - name: Install Python build dependencies (sdist)
        run: |
          python -m pip install --upgrade pip build
          # Ensure pyproject.toml lists setuptools, wheel, scikit-build, cython etc. in [build-system].requires

      - name: Build Python sdist
        run: python -m build --sdist

      - name: Upload Python sdist Artifact
        uses: actions/upload-artifact@v4
        with:
          name: python-sdist
          path: dist/*.tar.gz

  deploy_pypi:
    name: Deploy to PyPI
    if: startsWith(github.ref, 'refs/tags') # Only run on tags
    needs: [build_wheels, build_sdist]
    runs-on: ubuntu-latest
    environment: pypi # Define an environment for PyPI deployment (good for protection rules)
    permissions:
      id-token: write # Required for trusted publishing
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ~/artifacts # All artifacts will be downloaded into subdirectories here

      - name: Set up Python for Twine
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Twine
        run: python -m pip install --upgrade pip twine

      - name: Display downloaded artifacts structure
        run: ls -R ~/artifacts

      - name: Upload to PyPI
        # Ensure you have configured trusted publishing in PyPI and GitHub
        run: |
          echo "Listing all wheel and sdist files to be uploaded:"
          find ~/artifacts -name '*.whl' -print -exec echo \;
          find ~/artifacts -name '*.tar.gz' -print -exec echo \;
          python -m twine upload --skip-existing $(find ~/artifacts -name '*.whl' -o -name '*.tar.gz')