# Synthizer3D v0.9.1 - ManyLinux Python Wheels Build Workflow
# Questo workflow compila wheel Python manylinux compatibili per Synthizer3D,
# una libreria audio 3D. Include tutte le dipendenze audio (Opus, Vorbis, FAAD2)
# e supporta sia architetture x86_64 che i686.
# Versione: 0.9.1
# Ultimo aggiornamento: Giugno 2025
# Autore: Assistant & Team Synthizer3D

name: Build and Publish Python Wheels for ManyLinux

on:
  push:
    tags:
      - 'v*'
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 0.9.1)'
        required: true
        default: '0.9.1'
      upload_to_pypi:
        description: 'Upload to PyPI (true/false)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  VCPKG_DEFAULT_TRIPLET: x64-linux
  VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
  SYNTHIZER_VERSION: ${{ github.event.inputs.version || '0.9.1' }}

jobs:
  build-manylinux:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      matrix:
        include:
          # x86_64 - usa manylinux_2_28 moderno (AlmaLinux 8)
          - CI_ARCH: x86_64
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: 3.8
          - CI_ARCH: x86_64
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: 3.9
          - CI_ARCH: x86_64
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: 3.10
          - CI_ARCH: x86_64
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: 3.11
          - CI_ARCH: x86_64
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: 3.12
          # i686 - usa manylinux2014 (CentOS 7, ultimo che supporta i686)
          - CI_ARCH: i686
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: 3.8
          - CI_ARCH: i686
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: 3.9
          - CI_ARCH: i686
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: 3.10
          - CI_ARCH: i686
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: 3.11
          - CI_ARCH: i686
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: 3.12

    name: "Build ManyLinux (${{ matrix.CI_ARCH }}, ${{ matrix.MANYLINUX_VERSION }}) Python ${{ matrix.PYVERSION }}"

    container:
      image: quay.io/pypa/${{ matrix.MANYLINUX_VERSION }}_${{ matrix.CI_ARCH }}
      options: --user root

    env:
      CI_ARCH: ${{ matrix.CI_ARCH }}
      MANYLINUX_VERSION: ${{ matrix.MANYLINUX_VERSION }}
      PYVERSION: ${{ matrix.PYVERSION }}
      EFFECTIVE_VCPKG_INSTALLED_DIR_BASE: ${{ github.workspace }}/vcpkg_installed

    steps:
      - name: Pull Docker image with retry
        timeout-minutes: 15
        run: |
          echo "üê≥ Ensuring Docker image is fully loaded..."
          echo "Container info:"
          cat /etc/os-release || true
          echo "Python versions available:"
          ls -la /opt/python/ || true
          
          # Fix potential Git permission issues in container
          git config --global --add safe.directory "*"

      - name: Checkout Synthizer3D source code (without submodules)
        uses: actions/checkout@v4
        timeout-minutes: 5
        with:
          fetch-depth: 1
          submodules: false
          clean: false

      - name: Check if synthizer-c directory exists
        run: |
          echo "üìÅ Checking project structure..."
          ls -la
          if [ -d "synthizer-c" ]; then
            echo "‚úÖ synthizer-c directory found"
            ls -la synthizer-c/
          else
            echo "‚ùå synthizer-c directory NOT found - submodules needed"
          fi

      - name: Initialize and update submodules with retry logic
        timeout-minutes: 15
        continue-on-error: true
        run: |
          echo "üîÑ Initializing and updating submodules with retry logic..."
          
          # Fix Git safe directory issues in container
          git config --global --add safe.directory "$(pwd)"
          git config --global --add safe.directory "*"
          
          # Funzione di retry per submoduli
          retry_submodule_update() {
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt of $max_attempts..."
              
              # Prima inizializza i submoduli
              if git submodule init; then
                echo "‚úÖ Submodules initialized"
                
                # Poi aggiorna con timeout e opzioni conservative
                if timeout 300 git submodule update --recursive --depth=1 --jobs=2 --init; then
                  echo "‚úÖ Submodules updated successfully!"
                  return 0
                else
                  echo "‚ùå Submodule update failed on attempt $attempt"
                fi
              else
                echo "‚ùå Submodule init failed on attempt $attempt"
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                echo "‚è≥ Waiting 30 seconds before retry..."
                sleep 30
              fi
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå All attempts failed. Trying fallback approach..."
            return 1
          }
          
          # Prova il normale update
          if ! retry_submodule_update; then
            echo "üîß Fallback: Trying to update essential submodules only..."
            
            # Se synthizer-c esiste nei submoduli, proviamo solo quello
            if git submodule status | grep -q synthizer-c; then
              echo "Updating only synthizer-c submodule..."
              git submodule update --init --depth=1 synthizer-c || true
            fi
          fi
          
          echo "üìÇ Final submodule status:"
          git submodule status || true

      - name: Verify essential files exist
        run: |
          echo "üîç Verifying essential files for build..."
          
          # Controlla se abbiamo i file necessari
          if [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
            echo "‚úÖ Python build files found"
          else
            echo "‚ùå No Python build files found"
            exit 1
          fi
          
          if [ -d "synthizer-c" ]; then
            echo "‚úÖ synthizer-c directory found"
            ls -la synthizer-c/
          else
            echo "‚ùå synthizer-c directory missing - this may cause build issues"
          fi

      - name: Set environment variables for Python path
        run: |
          echo "üêç Setting up Python ${{ matrix.PYVERSION }} environment..."
          if [ "${{ matrix.PYVERSION }}" = "3.8" ]; then
            echo "PYTHON_PATH=/opt/python/cp38-cp38" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.9" ]; then
            echo "PYTHON_PATH=/opt/python/cp39-cp39" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.10" ]; then
            echo "PYTHON_PATH=/opt/python/cp310-cp310" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.11" ]; then
            echo "PYTHON_PATH=/opt/python/cp311-cp311" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.12" ]; then
            echo "PYTHON_PATH=/opt/python/cp312-cp312" >> $GITHUB_ENV
          fi

      - name: Setup vcpkg with cache
        uses: lukka/run-vcpkg@v11
        timeout-minutes: 15
        with:
          vcpkgGitCommitId: '8eb57355a4ffb410a2e94c07b4dca2dffbee8e50'
          vcpkgJsonGlob: 'synthizer-c/vcpkg.json'
          
      - name: Cache vcpkg binary cache
        uses: actions/cache@v4
        timeout-minutes: 5
        with:
          path: ${{ github.workspace }}/vcpkg_cache
          key: vcpkg-${{ matrix.MANYLINUX_VERSION }}-${{ matrix.CI_ARCH }}-${{ hashFiles('synthizer-c/vcpkg.json') }}
          restore-keys: |
            vcpkg-${{ matrix.MANYLINUX_VERSION }}-${{ matrix.CI_ARCH }}-

      - name: Set vcpkg binary cache directory
        run: |
          mkdir -p "${{ github.workspace }}/vcpkg_cache"
          echo "VCPKG_DEFAULT_BINARY_CACHE=${{ github.workspace }}/vcpkg_cache" >> $GITHUB_ENV

      - name: Install vcpkg audio dependencies (Opus, Vorbis, FAAD2)
        timeout-minutes: 20
        run: |
          echo "üéµ Installing audio libraries via vcpkg..."
          cd synthizer-c
          echo "Working directory: $(pwd)"
          echo "Contents of synthizer-c:"
          ls -la
          
          echo "Running vcpkg install command..."
          "$VCPKG_ROOT/vcpkg" install --triplet=$VCPKG_DEFAULT_TRIPLET --feature-flags=versions
          
          echo "Setting CMAKE_PREFIX_PATH and library paths..."
          TARGET_CMAKE_PREFIX_PATH="${EFFECTIVE_VCPKG_INSTALLED_DIR_BASE}/$VCPKG_DEFAULT_TRIPLET"
          echo "Target CMAKE_PREFIX_PATH will be: $TARGET_CMAKE_PREFIX_PATH"
          
          if [ -d "$TARGET_CMAKE_PREFIX_PATH" ]; then
            echo "‚úÖ Confirmed: Target directory for CMAKE_PREFIX_PATH exists: $TARGET_CMAKE_PREFIX_PATH"
            echo "CMAKE_PREFIX_PATH=$TARGET_CMAKE_PREFIX_PATH" >> $GITHUB_ENV
            echo "LD_LIBRARY_PATH=$TARGET_CMAKE_PREFIX_PATH/lib:$LD_LIBRARY_PATH" >> $GITHUB_ENV
            echo "PKG_CONFIG_PATH=$TARGET_CMAKE_PREFIX_PATH/lib/pkgconfig:$PKG_CONFIG_PATH" >> $GITHUB_ENV
          else
            echo "‚ùå ERROR: Expected vcpkg installed directory not found: $TARGET_CMAKE_PREFIX_PATH"
            echo "Available directories in $EFFECTIVE_VCPKG_INSTALLED_DIR_BASE:"
            ls -la "$EFFECTIVE_VCPKG_INSTALLED_DIR_BASE" || echo "Base directory not found"
            exit 1
          fi
          
          echo "‚úÖ Finished vcpkg install command."

      - name: Install Python build dependencies
        timeout-minutes: 10
        run: |
          echo "üì¶ Installing Python build tools..."
          $PYTHON_PATH/bin/python -m pip install --upgrade pip
          $PYTHON_PATH/bin/pip install ninja cmake wheel tomli setuptools packaging distro scikit-build cython build auditwheel twine

      - name: Set version in setup.py and pyproject.toml
        run: |
          echo "üè∑Ô∏è Setting version to: ${{ env.SYNTHIZER_VERSION }}"
          
          # Aggiorna version in setup.py se esiste
          if [ -f "setup.py" ]; then
            sed -i "s/version=['\"][^'\"]*['\"]/version='${{ env.SYNTHIZER_VERSION }}'/g" setup.py
            echo "‚úÖ Updated setup.py with version ${{ env.SYNTHIZER_VERSION }}"
          fi
          
          # Aggiorna version in pyproject.toml se esiste
          if [ -f "pyproject.toml" ]; then
            sed -i "s/version = ['\"][^'\"]*['\"]/version = \"${{ env.SYNTHIZER_VERSION }}\"/g" pyproject.toml
            echo "‚úÖ Updated pyproject.toml with version ${{ env.SYNTHIZER_VERSION }}"
          fi
          
          # Verifica le modifiche
          echo "=== Current setup.py version line ==="
          grep -n "version" setup.py || echo "No version found in setup.py"
          echo "=== Current pyproject.toml version line ==="
          grep -n "version" pyproject.toml || echo "No version found in pyproject.toml"

      - name: Run C/C++ code vendoring script
        timeout-minutes: 5
        run: |
          echo "üìÅ Running Synthizer vendoring script..."
          python synthizer-c/vendor.py synthizer-vendored

      - name: Fix C++ compilation issues for modern compilers
        run: |
          echo "üîß Fixing C++20 template-id constructor issues..."
          
          # Fix nel file property_automation_timeline.hpp
          if [ -f "synthizer-vendored/include/synthizer/property_automation_timeline.hpp" ]; then
            sed -i 's/PropertyAutomationPoint<N>(const PropertyAutomationPoint<N> &) = default;/PropertyAutomationPoint(const PropertyAutomationPoint<N> \&) = default;/g' \
              synthizer-vendored/include/synthizer/property_automation_timeline.hpp
            echo "‚úÖ Fixed PropertyAutomationPoint constructor"
          fi
          
          # Fix per il cast di funzioni in mp3.hpp
          if [ -f "synthizer-vendored/include/synthizer/decoders/mp3.hpp" ]; then
            # Cercare il cast problematico e sostituirlo
            sed -i 's/local_seek_cb_for_init = (drmp3_seek_proc)seek_cb;/local_seek_cb_for_init = reinterpret_cast<drmp3_seek_proc>(seek_cb);/g' \
              synthizer-vendored/include/synthizer/decoders/mp3.hpp
            echo "‚úÖ Fixed function cast in mp3.hpp"
          fi
          
          # Disabilita -Werror nei CMakeLists.txt se presente
          find synthizer-vendored -name "CMakeLists.txt" -exec sed -i 's/-Werror//g' {} \;
          find synthizer-vendored -name "*.cmake" -exec sed -i 's/-Werror//g' {} \;
          
          echo "‚úÖ C++ fixes applied"

      - name: Build Python Wheels (ManyLinux ${{ matrix.CI_ARCH }})
        timeout-minutes: 20
        env:
          # CMAKE_PREFIX_PATH √® impostato tramite GITHUB_ENV
          SYNTHIZER_EXPECTED_VCPKG_PATH_FOR_DEBUG: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/${{ env.VCPKG_DEFAULT_TRIPLET }}
          # Flag per risolvere errori di compilazione C++
          CXXFLAGS: "-Wno-template-id-cdtor -Wno-cast-function-type -Wno-error"
          CFLAGS: "-Wno-error"
        run: |
          echo "üî® Building Synthizer3D wheel for $CI_ARCH..."
          cd "$GITHUB_WORKSPACE"
          echo "Architecture: $CI_ARCH"
          echo "ManyLinux version: $MANYLINUX_VERSION"
          echo "Current CMAKE_PREFIX_PATH for build is: $CMAKE_PREFIX_PATH"
          echo "EFFECTIVE_VCPKG_INSTALLED_DIR_BASE for build is: $EFFECTIVE_VCPKG_INSTALLED_DIR_BASE"
          echo "Synthizer expects vcpkg path (for debug/verification): $SYNTHIZER_EXPECTED_VCPKG_PATH_FOR_DEBUG"
          echo "Current LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
          echo "Current PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          echo "CXXFLAGS: $CXXFLAGS"
          echo "CFLAGS: $CFLAGS"
          
          $PYTHON_PATH/bin/python -m build --wheel --no-isolation
          echo "‚úÖ Wheel built successfully!"

      - name: Debug vcpkg installation
        run: |
          echo "üîç Debugging vcpkg installation..."
          VCPKG_INSTALLED_TRIPLET_DIR="$EFFECTIVE_VCPKG_INSTALLED_DIR_BASE/$VCPKG_DEFAULT_TRIPLET"
          echo "Listing contents of effective vcpkg directory: $VCPKG_INSTALLED_TRIPLET_DIR ..."
          if [ -d "$VCPKG_INSTALLED_TRIPLET_DIR" ]; then
            find "$VCPKG_INSTALLED_TRIPLET_DIR" -maxdepth 3 -type f -exec ls -la {} \; | head -50
          else
            echo "WARNING: $VCPKG_INSTALLED_TRIPLET_DIR does not exist."
          fi
          
          VCPKG_INSTALLED_LIB_DIR="$VCPKG_INSTALLED_TRIPLET_DIR/lib"
          if [ -d "$VCPKG_INSTALLED_LIB_DIR" ]; then
            echo "Listing contents of $VCPKG_INSTALLED_LIB_DIR ..."
            ls -la "$VCPKG_INSTALLED_LIB_DIR"
          else
            echo "WARNING: $VCPKG_INSTALLED_LIB_DIR does not exist or is not a directory."
          fi
          
          VCPKG_INSTALLED_BIN_DIR="$VCPKG_INSTALLED_TRIPLET_DIR/bin"
          if [ -d "$VCPKG_INSTALLED_BIN_DIR" ]; then
            echo "Listing contents of $VCPKG_INSTALLED_BIN_DIR ..."
            ls -la "$VCPKG_INSTALLED_BIN_DIR"
          else
            echo "WARNING: $VCPKG_INSTALLED_BIN_DIR does not exist or is not a directory."
          fi

      - name: Repair wheels with auditwheel (make manylinux compatible)
        timeout-minutes: 10
        env:
          VCPKG_INSTALLED_TRIPLET_DIR: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/${{ env.VCPKG_DEFAULT_TRIPLET }}
          VCPKG_INSTALLED_LIB_DIR: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/${{ env.VCPKG_DEFAULT_TRIPLET }}/lib
        run: |
          echo "üõ†Ô∏è Repairing wheels with auditwheel..."
          echo "Path vcpkg (lib) che sar√† aggiunto a auditwheel: $VCPKG_INSTALLED_LIB_DIR"
          
          # Crea directory wheelhouse se non esiste
          mkdir -p wheelhouse
          
          for wheel in dist/*.whl; do
            if [ -f "$wheel" ]; then
              echo "Repairing wheel: $wheel"
              # Usa auditwheel per riparare la wheel e renderla compatibile con manylinux
              # Sintassi corretta: repair prima di --plat-tag
              $PYTHON_PATH/bin/auditwheel repair \
                "$wheel" \
                --plat-tag "${MANYLINUX_VERSION}_${CI_ARCH}" \
                --wheel-dir wheelhouse
            fi
          done
          
          echo "Listing repaired wheels in wheelhouse/:"
          ls -la wheelhouse/*.whl || echo "No wheels found in wheelhouse/"
          
          # Sposta le wheel riparate in dist/ per coerenza con gli altri job
          if ls wheelhouse/*.whl 1> /dev/null 2>&1; then
            cp wheelhouse/*.whl dist/
            echo "‚úÖ Copied repaired wheels to dist/:"
            ls -la dist/*.whl
          fi

      - name: Verify wheel contents and metadata
        run: |
          echo "üîç Verifying wheel contents..."
          for wheel in dist/*.whl; do
            if [ -f "$wheel" ]; then
              echo "=== Wheel: $wheel ==="
              $PYTHON_PATH/bin/python -m zipfile -l "$wheel" | head -20
              echo ""
              # Verifica metadata con auditwheel
              echo "=== Auditwheel show output ==="
              $PYTHON_PATH/bin/auditwheel show "$wheel" || echo "Auditwheel show failed"
              echo ""
            fi
          done

      - name: Upload wheel artifacts
        uses: actions/upload-artifact@v4
        timeout-minutes: 5
        with:
          name: python-wheels-${{ matrix.MANYLINUX_VERSION }}-${{ matrix.CI_ARCH }}-py${{ matrix.PYVERSION }}
          path: dist/*.whl

  # Job separato per la pubblicazione (solo quando richiesto)
  publish-to-pypi:
    needs: build-manylinux
    runs-on: ubuntu-latest
    if: >
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.upload_to_pypi == 'true')
    
    environment:
      name: pypi
      url: https://pypi.org/p/synthizer3d

    permissions:
      id-token: write  # Per PyPI trusted publishing
      
    steps:
      - name: Download all wheel artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: python-wheels-*
          path: dist
          merge-multiple: true

      - name: List all wheels to be published
        run: |
          echo "üéØ Wheels ready for publication:"
          ls -la dist/*.whl
          echo ""
          echo "Total wheels: $(ls dist/*.whl | wc -l)"

      - name: Publish to Test PyPI (for testing)
        if: github.event_name == 'workflow_dispatch'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          packages-dir: dist/
          verbose: true

      - name: Publish to PyPI (production)
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/
          verbose: true

  # Job finale per summary
  build-summary:
    needs: build-manylinux
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Build Summary
        run: |
          echo "# üéµ Synthizer3D v${{ env.SYNTHIZER_VERSION }} Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build Matrix Results" >> $GITHUB_STEP_SUMMARY
          echo "- **x86_64 wheels**: 5 versions (Python 3.8-3.12) with manylinux_2_28" >> $GITHUB_STEP_SUMMARY
          echo "- **i686 wheels**: 5 versions (Python 3.8-3.12) with manylinux2014" >> $GITHUB_STEP_SUMMARY
          echo "- **Total expected wheels**: 10" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Audio Libraries Included" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **Opus**: Advanced audio codec" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **Vorbis**: OGG Vorbis audio codec" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **FAAD2**: AAC audio decoder" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **OGG**: Container format support" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.build-manylinux.result }}" = "success" ]; then
            echo "‚úÖ **Build Status**: SUCCESS" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Build Status**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi