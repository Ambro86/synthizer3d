# Workflow for Synthizer3d
# by Ambro86
#Ver. 0.9.0
# Trigger del workflow: si attiva ad ogni push e pull request
on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch: # Permette l'avvio manuale dalla tab Azioni di GitHub
jobs:
  # Job per costruire le wheel su Windows
  windows-build:
    name: Build Windows (${{ matrix.CI_ARCH }}) Python ${{ matrix.PYVERSION }}
    runs-on: windows-latest
    env:
      PYVERSION: ${{ matrix.PYVERSION }}
      CI_ARCH_LOWER: ${{ (matrix.CI_ARCH == 'x86' && 'x86' || 'x64') }}
      CI_WINDOWS: "1"
      CI_ARCH_ENV: ${{ matrix.CI_ARCH }}
      VCPKG_DEFAULT_TRIPLET: ${{ (matrix.CI_ARCH == 'x86' && 'x86-windows' || 'x64-windows') }}
      # Questo √® il percorso dove vcpkg in modalit√† manifest (con vcpkg.json) installa di default.
      EFFECTIVE_VCPKG_INSTALLED_DIR_BASE: ${{ github.workspace }}\vcpkg_installed
    strategy:
      fail-fast: false
      matrix:
        PYVERSION: ["3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]
        CI_ARCH: ["x64", "x86"]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python ${{ matrix.PYVERSION }} (${{ env.CI_ARCH_LOWER }})
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.PYVERSION }}
          architecture: ${{ env.CI_ARCH_LOWER }}

      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      - name: Run C/C++ code vendoring script
        run: python synthizer-c/vendor.py synthizer-vendored
        # Assicurati che questo script, se modifica/popola vcpkg_installed, sia coerente
        # con la modalit√† manifest di vcpkg o che non crei conflitti.

      - name: Cache Pip (Windows ${{ matrix.CI_ARCH }})
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-${{ env.PYVERSION }}-${{ matrix.CI_ARCH }}-${{ hashFiles('**/requirements.txt', '**/setup.py', 'vcpkg.json', 'synthizer-c/vendor.py') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ env.PYVERSION }}-${{ matrix.CI_ARCH }}-

      - name: Setup MSVC Developer Command Prompt
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ env.CI_ARCH_LOWER }}

      - name: Setup vcpkg with retry
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: 'vcpkg.json'
          runVcpkgInstall: true
        continue-on-error: true
        
      - name: Retry vcpkg install on failure
        if: failure()
        timeout-minutes: 45
        run: |
          echo "üîÑ Retrying vcpkg install due to network issues..."
          sleep 30
          
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3..."
            if "$VCPKG_ROOT/vcpkg" install --triplet=$VCPKG_DEFAULT_TRIPLET --feature-flags=versions; then
              echo "‚úÖ vcpkg install succeeded on attempt $i"
              break
            else
              if [ $i -lt 3 ]; then
                echo "‚ùå Attempt $i failed, waiting $(($i * 60)) seconds..."
                sleep $(($i * 60))
              else
                echo "‚ùå All retry attempts failed"
                exit 1
              fi
            fi
          done

      - name: Install dependencies and set CMAKE_PREFIX_PATH (Windows)
        shell: pwsh
        run: |
          Write-Host "VCPKG_ROOT (tool directory from lukka/run-vcpkg) is $env:VCPKG_ROOT"
          Write-Host "VCPKG_DEFAULT_TRIPLET is $env:VCPKG_DEFAULT_TRIPLET"
          Write-Host "GITHUB_WORKSPACE is $env:GITHUB_WORKSPACE"
          Write-Host "Initial EFFECTIVE_VCPKG_INSTALLED_DIR_BASE (from job env, target for manifest install) is $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE"
          
          if (-not $env:VCPKG_ROOT) {
            Write-Error "VCPKG_ROOT not set. This should be set by the lukka/run-vcpkg action."
            exit 1
          }

          # Esegui vcpkg install. Se vcpkg.json √® in $env:GITHUB_WORKSPACE (CWD),
          # installer√† in $env:GITHUB_WORKSPACE/vcpkg_installed/$env:VCPKG_DEFAULT_TRIPLET
          # che corrisponde a $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE/$env:VCPKG_DEFAULT_TRIPLET
          # La CurrentWorkingDirectory per gli script eseguiti da 'run:' √® $GITHUB_WORKSPACE.
          & "$env:VCPKG_ROOT\vcpkg.exe" install --triplet $env:VCPKG_DEFAULT_TRIPLET
          Write-Host "Finished vcpkg install command."
          
          # CMAKE_PREFIX_PATH deve puntare a dove vcpkg ha effettivamente installato i pacchetti.
          # Con la modalit√† manifest, questo √® $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE/$env:VCPKG_DEFAULT_TRIPLET.
          $cmakePrefixPathValue = Join-Path $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE $env:VCPKG_DEFAULT_TRIPLET
          
          Write-Host "Verifying existence of target CMAKE_PREFIX_PATH: $cmakePrefixPathValue"
          if (-not (Test-Path $cmakePrefixPathValue -PathType Container)) {
            Write-Warning "ATTENZIONE: La directory $cmakePrefixPathValue (target per CMAKE_PREFIX_PATH) NON esiste dopo vcpkg install."
            Write-Warning "Questo indica che vcpkg non ha installato nella posizione manifest attesa."
            Write-Warning "Contenuto di $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE per debug:"
            Get-ChildItem -Path $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE -ErrorAction SilentlyContinue -Depth 1 || Write-Warning "$env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE non esiste o √® vuoto."
            
            # Fallback per debug: controlla la directory di installazione classica di vcpkg
            $classicVcpkgInstalledPath = Join-Path (Join-Path $env:VCPKG_ROOT "installed") $env:VCPKG_DEFAULT_TRIPLET
            Write-Warning "Controllo del percorso di installazione classico di vcpkg per debug: $classicVcpkgInstalledPath"
            if(Test-Path $classicVcpkgInstalledPath -PathType Container){
                Write-Warning "Il percorso classico $classicVcpkgInstalledPath ESISTE. Questo √® fonte di confusione se era prevista la modalit√† manifest."
            } else {
                Write-Warning "Anche il percorso classico $classicVcpkgInstalledPath NON esiste."
            }
          } else {
            Write-Host "Confermato: La directory target per CMAKE_PREFIX_PATH esiste: $cmakePrefixPathValue"
          }

          echo "CMAKE_PREFIX_PATH=$cmakePrefixPathValue" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "CMAKE_PREFIX_PATH impostato a $cmakePrefixPathValue"
          # EFFECTIVE_VCPKG_INSTALLED_DIR_BASE √® gi√† corretto dall'env del job, non serve aggiornarlo di nuovo in GITHUB_ENV
          # se la nostra assunzione sulla modalit√† manifest √® corretta.

      - name: Install Python build dependencies (Windows)
        run: |
          python -m pip install --upgrade pip
          pip install ninja cmake wheel tomli setuptools packaging distro scikit-build cython build delvewheel

      - name: Build Python Wheels (Windows ${{ matrix.CI_ARCH }})
        shell: powershell
        env:
          # CMAKE_PREFIX_PATH √® impostato tramite GITHUB_ENV.
          # SYNTHIZER_EXPECTED_VCPKG_PATH_FOR_DEBUG user√† il valore di EFFECTIVE_VCPKG_INSTALLED_DIR_BASE dall'env del job.
          SYNTHIZER_EXPECTED_VCPKG_PATH_FOR_DEBUG: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}\${{ env.VCPKG_DEFAULT_TRIPLET }}
        run: |
          Set-Location $Env:GITHUB_WORKSPACE
          Write-Host "Arch: ${{ env.CI_ARCH_LOWER }}"
          Write-Host "Current CMAKE_PREFIX_PATH for build is: $env:CMAKE_PREFIX_PATH"
          Write-Host "EFFECTIVE_VCPKG_INSTALLED_DIR_BASE for build is: $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE"
          Write-Host "Synthizer expects vcpkg path (for debug/verification): $env:SYNTHIZER_EXPECTED_VCPKG_PATH_FOR_DEBUG"
          python -m build --wheel --no-isolation

      - name: List vcpkg installed files for debugging
        shell: powershell
        run: |
          $vcpkgInstalledTripletDir = Join-Path $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE $env:VCPKG_DEFAULT_TRIPLET
          Write-Host "Listing contents of effective vcpkg directory: $vcpkgInstalledTripletDir ..."
          if (Test-Path $vcpkgInstalledTripletDir -PathType Container) {
            Get-ChildItem -Path $vcpkgInstalledTripletDir -Recurse -Depth 2 | Select-Object FullName, Length, Mode | Format-Table -AutoSize -Wrap
          } else {
            Write-Warning "$vcpkgInstalledTripletDir does not exist."
          }

          $vcpkgInstalledBinDir = Join-Path $vcpkgInstalledTripletDir "bin"
          if (Test-Path $vcpkgInstalledBinDir -PathType Container) {
            Write-Host "Listing contents of $vcpkgInstalledBinDir ..."
            Get-ChildItem -Path $vcpkgInstalledBinDir -Recurse | Select-Object FullName, Length, Mode | Format-Table -AutoSize -Wrap
          } else {
            Write-Warning "$vcpkgInstalledBinDir does not exist or is not a directory."
          }

          $vcpkgInstalledLibDir = Join-Path $vcpkgInstalledTripletDir "lib"
          if (Test-Path $vcpkgInstalledLibDir -PathType Container) {
            Write-Host "Listing contents of $vcpkgInstalledLibDir ..."
            Get-ChildItem -Path $vcpkgInstalledLibDir -Recurse | Select-Object FullName, Length, Mode | Format-Table -AutoSize -Wrap
          } else {
            Write-Warning "$vcpkgInstalledLibDir does not exist or is not a directory."
          }
        continue-on-error: true

      - name: Repair Wheel with Delvewheel (Windows ${{ matrix.CI_ARCH }})
        shell: powershell
        run: |
          $vcpkgInstalledTripletDir = Join-Path $env:EFFECTIVE_VCPKG_INSTALLED_DIR_BASE $env:VCPKG_DEFAULT_TRIPLET
          $vcpkgInstalledBinDir = Join-Path $vcpkgInstalledTripletDir "bin"
          $vcpkgInstalledLibDir = Join-Path $vcpkgInstalledTripletDir "lib"
          
          Write-Host "Path vcpkg (bin) che sar√† aggiunto a delvewheel: $vcpkgInstalledBinDir"
          Write-Host "Path vcpkg (lib) che sar√† aggiunto a delvewheel: $vcpkgInstalledLibDir"

          foreach ($wheel in (Get-ChildItem -Path dist/*.whl)) {
            Write-Host "Repairing wheel: $($wheel.FullName)"
            # Aggiungi i percorsi delle DLL di vcpkg a delvewheel.
            # Delvewheel cercher√† le dipendenze in queste directory.
            # Potrebbe essere necessario solo -add-path per la directory bin, o entrambe.
            # Il flag -w sovrascrive la wheel originale con quella riparata nella stessa directory (dist/)
            delvewheel repair --add-path "$vcpkgInstalledBinDir;$vcpkgInstalledLibDir" -w "$($wheel.DirectoryName)" "$($wheel.FullName)"
          }
          Write-Host "Listing repaired wheels in dist/:"
          Get-ChildItem -Path dist/*.whl | ForEach-Object { Write-Host $_.Name }

      - name: Upload Python Wheel Artifact (Windows ${{ matrix.CI_ARCH }})
        uses: actions/upload-artifact@v4
        with:
          name: python-wheels-win-${{ matrix.CI_ARCH }}-${{ matrix.PYVERSION }}
          path: dist/*.whl
  # Job per costruire le wheel su Linux x86_64
  linux-x64-build:
    name: Build Linux (x86_64) Python ${{ matrix.PYVERSION }}
    runs-on: ubuntu-latest
    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        PYVERSION: ["3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]

    container:
      image: quay.io/pypa/manylinux_2_28_x86_64
      options: --user root

    env:
      CI_ARCH: x86_64
      MANYLINUX_VERSION: manylinux_2_28
      PYVERSION: ${{ matrix.PYVERSION }}
      VCPKG_DEFAULT_TRIPLET: x64-linux
      EFFECTIVE_VCPKG_INSTALLED_DIR_BASE: ${{ github.workspace }}/vcpkg_installed

    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
      
      - name: Set environment variables for Python path
        run: |
          echo "üêç Setting up Python ${{ matrix.PYVERSION }} environment..."
          if [ "${{ matrix.PYVERSION }}" = "3.8" ]; then echo "PYTHON_PATH=/opt/python/cp38-cp38" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.9" ]; then echo "PYTHON_PATH=/opt/python/cp39-cp39" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.10" ]; then echo "PYTHON_PATH=/opt/python/cp310-cp310" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.11" ]; then echo "PYTHON_PATH=/opt/python/cp311-cp311" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.12" ]; then echo "PYTHON_PATH=/opt/python/cp312-cp312" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.13" ]; then echo "PYTHON_PATH=/opt/python/cp313-cp313" >> $GITHUB_ENV
          fi

      - name: Install system and Python build dependencies
        timeout-minutes: 45
        run: |
          echo "üì¶ Installing system dependencies..."
          if command -v dnf >/dev/null 2>&1; then
            dnf install -y curl zip unzip tar cmake make gcc-c++ openssl-devel
          elif command -v yum >/dev/null 2>&1; then
            yum install -y curl zip unzip tar cmake make gcc-c++ openssl-devel
          fi
          
          echo "üì¶ Installing Python build tools (including ninja)..."
          $PYTHON_PATH/bin/python -m pip install --upgrade pip
          $PYTHON_PATH/bin/pip install ninja cmake wheel tomli setuptools packaging distro scikit-build cython build auditwheel twine

      - name: Set vcpkg Cache Path
        run: echo "VCPKG_DEFAULT_BINARY_CACHE=${{ github.workspace }}/vcpkg_cache" >> $GITHUB_ENV

      - name: Cache vcpkg binary cache
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/vcpkg_cache
          key: vcpkg-cache-${{ env.VCPKG_DEFAULT_TRIPLET }}-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            vcpkg-cache-${{ env.VCPKG_DEFAULT_TRIPLET }}-
            
      - name: Cache vcpkg packages
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/vcpkg_installed
          key: vcpkg-packages-${{ env.VCPKG_DEFAULT_TRIPLET }}-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            vcpkg-packages-${{ env.VCPKG_DEFAULT_TRIPLET }}-
      - name: Setup vcpkg with retry
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: 'vcpkg.json'
          runVcpkgInstall: true
        continue-on-error: true
        
      - name: Retry vcpkg install on failure
        if: failure()
        timeout-minutes: 45
        run: |
          echo "üîÑ Retrying vcpkg install due to network issues..."
          sleep 30
          
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3..."
            if "$VCPKG_ROOT/vcpkg" install --triplet=$VCPKG_DEFAULT_TRIPLET --feature-flags=versions; then
              echo "‚úÖ vcpkg install succeeded on attempt $i"
              break
            else
              if [ $i -lt 3 ]; then
                echo "‚ùå Attempt $i failed, waiting $(($i * 60)) seconds..."
                sleep $(($i * 60))
              else
                echo "‚ùå All retry attempts failed"
                exit 1
              fi
            fi
          done
      - name: Run C/C++ code vendoring script
        timeout-minutes: 5
        run: |
          $PYTHON_PATH/bin/python synthizer-c/vendor.py synthizer-vendored

      - name: Fix C++ compilation issues for modern compilers
        run: |
          echo "üîß Fixing C++ compilation issues..."
          if [ -f "synthizer-vendored/include/synthizer/property_automation_timeline.hpp" ]; then
            sed -i 's/PropertyAutomationPoint<N>(const PropertyAutomationPoint<N> &) = default;/PropertyAutomationPoint(const PropertyAutomationPoint<N> \&) = default;/g' \
              synthizer-vendored/include/synthizer/property_automation_timeline.hpp
          fi
          if [ -f "synthizer-vendored/include/synthizer/decoders/mp3.hpp" ]; then
            sed -i 's/local_seek_cb_for_init = (drmp3_seek_proc)seek_cb;/local_seek_cb_for_init = reinterpret_cast<drmp3_seek_proc>(seek_cb);/g' \
              synthizer-vendored/include/synthizer/decoders/mp3.hpp
          fi
          find synthizer-vendored -name "CMakeLists.txt" -exec sed -i 's/-Werror//g' {} \;
          find synthizer-vendored -name "*.cmake" -exec sed -i 's/-Werror//g' {} \;
      - name: Setup CMake paths for vcpkg libraries
        run: |
          echo "üîß Setting up CMake paths for vcpkg libraries..."
          
          echo "üîç Debug: Environment variables from run-vcpkg action..."
          echo "VCPKG_ROOT: $VCPKG_ROOT"
          echo "VCPKG_DEFAULT_TRIPLET: $VCPKG_DEFAULT_TRIPLET"
          
          # Find the actual vcpkg installation directory
          echo "üîç Searching for vcpkg installation directory..."
          VCPKG_INSTALLED_PATH=""
          
          # Method 1: Look for the actual installation directory
          if [ -d "$(pwd)/vcpkg_installed" ]; then
            VCPKG_INSTALLED_PATH="$(pwd)/vcpkg_installed/$VCPKG_DEFAULT_TRIPLET"
            echo "‚úÖ Found Method 1: $VCPKG_INSTALLED_PATH"
          fi
          
          # Method 2: Search in workspace for any vcpkg_installed directory
          if [ -z "$VCPKG_INSTALLED_PATH" ] || [ ! -d "$VCPKG_INSTALLED_PATH" ]; then
            SEARCH_PATH=$(find "$(pwd)" -name "vcpkg_installed" -type d | head -1)
            if [ -n "$SEARCH_PATH" ]; then
              VCPKG_INSTALLED_PATH="$SEARCH_PATH/$VCPKG_DEFAULT_TRIPLET"
              echo "‚úÖ Found Method 2: $VCPKG_INSTALLED_PATH"
            fi
          fi
          
          # Method 3: Use the RUNVCPKG output (if available)
          if [ -z "$VCPKG_INSTALLED_PATH" ] || [ ! -d "$VCPKG_INSTALLED_PATH" ]; then
            # Look for any directory containing the triplet name
            TRIPLET_DIR=$(find "$(pwd)" -name "$VCPKG_DEFAULT_TRIPLET" -type d | grep vcpkg | head -1)
            if [ -n "$TRIPLET_DIR" ]; then
              VCPKG_INSTALLED_PATH="$TRIPLET_DIR"
              echo "‚úÖ Found Method 3: $VCPKG_INSTALLED_PATH"
            fi
          fi
          
          # Verify the path exists
          if [ -z "$VCPKG_INSTALLED_PATH" ] || [ ! -d "$VCPKG_INSTALLED_PATH" ]; then
            echo "‚ùå Could not find vcpkg installation directory"
            echo "üìÇ Workspace contents:"
            find "$(pwd)" -name "*vcpkg*" -type d | head -10
            echo "üìÇ Looking for any $VCPKG_DEFAULT_TRIPLET directories:"
            find "$(pwd)" -name "$VCPKG_DEFAULT_TRIPLET" -type d | head -5
            exit 1
          fi
          
          echo "‚úÖ Using vcpkg path: $VCPKG_INSTALLED_PATH"
          
          # Verify libraries are installed
          echo "üìÇ Checking installed libraries..."
          ls -la "$VCPKG_INSTALLED_PATH/lib/" | head -10 || echo "No lib directory found"
          ls -la "$VCPKG_INSTALLED_PATH/include/" | head -5 || echo "No include directory found"
          
          # Set environment variables for the build
          echo "CMAKE_PREFIX_PATH=${VCPKG_INSTALLED_PATH}" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=${VCPKG_INSTALLED_PATH}/lib/pkgconfig:${PKG_CONFIG_PATH}" >> $GITHUB_ENV
          echo "LD_LIBRARY_PATH=${VCPKG_INSTALLED_PATH}/lib:${LD_LIBRARY_PATH}" >> $GITHUB_ENV
          echo "VCPKG_INSTALLED_PATH=${VCPKG_INSTALLED_PATH}" >> $GITHUB_ENV
          echo "CMAKE_TOOLCHAIN_FILE=${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake" >> $GITHUB_ENV
          
          echo "‚úÖ Environment variables set for CMake build"
      - name: Build Python wheel
        timeout-minutes: 20
        env:
          # Flags per disabilitare errori di compilazione
          RUSTFLAGS: "-A warnings"
          CXXFLAGS: "-Wno-template-id-cdtor -Wno-cast-function-type -Wno-error"
          CFLAGS: "-Wno-error"
        run: |
          echo "üî® Building Python wheel with vcpkg toolchain..."
          
          echo "üìç Using paths:"
          echo "  CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
          echo "  PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          echo "  VCPKG_ROOT: $VCPKG_ROOT"
          echo "  VCPKG_INSTALLED_PATH: $VCPKG_INSTALLED_PATH"
          
          echo "üîç Final verification of vcpkg installation:"
          "$VCPKG_ROOT/vcpkg" list | grep -E "(vorbis|opus|ogg|faad)" || echo "No audio libraries found in vcpkg list"
          
          echo "üîç Checking for op_read_float symbol in opusfile library:"
          echo "üìÇ Available opusfile libraries:"
          find "${VCPKG_INSTALLED_PATH}" -name "*opus*" -type f | head -10
          
          if [ -f "${VCPKG_INSTALLED_PATH}/lib/libopusfile.a" ]; then
            echo "‚úÖ Found libopusfile.a"
            nm "${VCPKG_INSTALLED_PATH}/lib/libopusfile.a" | grep -E "(op_read|U op_)" || echo "No op_read symbols found in libopusfile.a"
            echo "üîç All symbols in libopusfile.a containing 'op_':"
            nm "${VCPKG_INSTALLED_PATH}/lib/libopusfile.a" | grep " T " | grep "op_" | head -10 || echo "No exported op_ symbols"
            echo "üîç Specifically checking for op_read_float:"
            nm "${VCPKG_INSTALLED_PATH}/lib/libopusfile.a" | grep "op_read_float" || echo "‚ùå op_read_float symbol NOT found in static library"
            
          else
            echo "‚ùå libopusfile.a not found"
          fi
          
          if [ -f "${VCPKG_INSTALLED_PATH}/lib/libopusfile.so" ]; then
            echo "‚úÖ Found libopusfile.so"
            nm -D "${VCPKG_INSTALLED_PATH}/lib/libopusfile.so" | grep op_read_float || echo "op_read_float not found in libopusfile.so"
          else
            echo "‚ùå libopusfile.so not found"
          fi
          
          echo "üîç Checking opusfile header availability:"
          if [ -f "${VCPKG_INSTALLED_PATH}/include/opus/opusfile.h" ]; then
            echo "‚úÖ opusfile.h header found"
            grep -n "op_read_float" "${VCPKG_INSTALLED_PATH}/include/opus/opusfile.h" | head -3
          else
            echo "‚ùå opusfile.h header not found"
            find "${VCPKG_INSTALLED_PATH}" -name "opusfile.h" -type f
          fi
          
          echo "üöÄ Starting Python wheel build with automatic op_read_float detection..."
          $PYTHON_PATH/bin/python -m build --wheel --no-isolation \
            --config-setting="cmake.args=-DCMAKE_TOOLCHAIN_FILE=${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake" \
            --config-setting="cmake.args=-DVCPKG_TARGET_TRIPLET=${VCPKG_DEFAULT_TRIPLET}" \
            --config-setting="cmake.args=-DCMAKE_PREFIX_PATH=${VCPKG_INSTALLED_PATH}" \
            --config-setting="cmake.args=-DVorbis_DIR=${VCPKG_INSTALLED_PATH}/share/Vorbis" \
            --config-setting="cmake.args=-DOgg_DIR=${VCPKG_INSTALLED_PATH}/share/Ogg" \
            --config-setting="cmake.args=-DOpus_DIR=${VCPKG_INSTALLED_PATH}/share/Opus" \
            --config-setting="cmake.args=-DOpusFile_DIR=${VCPKG_INSTALLED_PATH}/share/opusfile" \
            --config-setting="cmake.args=-DCMAKE_EXE_LINKER_FLAGS=-static-libgcc -static-libstdc++" \
            --config-setting="cmake.args=-DCMAKE_SHARED_LINKER_FLAGS=-static-libgcc -static-libstdc++" \
            --config-setting="cmake.verbose=True"

 
      - name: Debug vcpkg libraries and dependencies
        run: |
          echo "üîç Environment variables:"
          echo "VCPKG_ROOT: $VCPKG_ROOT"
          echo "EFFECTIVE_VCPKG_INSTALLED_DIR_BASE: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}"
          echo "VCPKG_DEFAULT_TRIPLET: $VCPKG_DEFAULT_TRIPLET"
          
          echo "üîç Checking if vcpkg installed directory exists..."
          ls -la ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/ || echo "Directory not found!"
          
          echo "üîç Checking vcpkg installed libraries..."
          if [ -d "${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/$VCPKG_DEFAULT_TRIPLET" ]; then
            find ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/$VCPKG_DEFAULT_TRIPLET -name "*.so*" | head -20
            echo "üîç Looking for audio libraries specifically..."
            find ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/$VCPKG_DEFAULT_TRIPLET -name "*ogg*" -o -name "*vorbis*" -o -name "*opus*"
          else
            echo "‚ùå vcpkg installed directory not found!"
            echo "Looking for vcpkg directories..."
            find /home/runner/work -name "vcpkg_installed" -type d 2>/dev/null || echo "No vcpkg_installed found"
          fi
          
          echo "üîç Checking built wheel content..."
          if ls dist/*.whl 1> /dev/null 2>&1; then
            echo "Found wheels:"
            ls -la dist/*.whl
            echo "üîç Checking wheel dependencies before repair..."
            $PYTHON_PATH/bin/python -m auditwheel show dist/*.whl
          else
            echo "‚ùå No wheels found in dist/"
          fi
          
          echo "üîç Checking synthizer module dependencies..."
          find . -name "*.so" -type f -exec echo "Checking: {}" \; -exec ldd {} \; 2>/dev/null || echo "No .so files found"
      - name: Repair wheels with auditwheel
        timeout-minutes: 10
        run: |
          echo "üõ†Ô∏è Repairing wheels with auditwheel..."
          echo "üîç Current LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
          echo "üîç VCPKG_INSTALLED_PATH: $VCPKG_INSTALLED_PATH"
          
          # Since we use static libraries, auditwheel should work without extra lib-dir
          for wheel in dist/*.whl; do
            if [ -f "$wheel" ]; then
              echo "üîß Repairing wheel: $wheel"
              $PYTHON_PATH/bin/auditwheel repair \
                "$wheel" \
                --plat "${MANYLINUX_VERSION}_${CI_ARCH}" \
                --wheel-dir wheelhouse
            fi
          done
          
          # RIMUOVI le wheel originali e mantieni solo quelle riparate
          rm -f dist/*.whl
          if ls wheelhouse/*.whl 1> /dev/null 2>&1; then
            cp wheelhouse/*.whl dist/
          fi
          echo "‚úÖ Repaired wheels:"
          ls -la dist/*.whl
      - name: Upload wheel artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-wheels-linux-x86_64-${{ matrix.PYVERSION }}
          path: dist/*.whl

  # Job per costruire le wheel su macOS (x64 - Intel Runner)
  macos-x64-build:
    name: Build macOS (x64) Python ${{ matrix.PYVERSION }}
    runs-on: macos-13 # Intel runner, o macos-latest se vuoi che scelga per x64
    env:
      PYVERSION: ${{ matrix.PYVERSION }}
      TARGET_ARCH: "x64"
      VCPKG_DEFAULT_TRIPLET: "x64-osx"
    strategy:
      fail-fast: false
      matrix:
        PYVERSION: ["3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python ${{ matrix.PYVERSION }} (x64)
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.PYVERSION }}
          architecture: 'x64' # Assicura Python x64

      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      - name: Run C/C++ code vendoring script
        run: python synthizer-c/vendor.py synthizer-vendored

      - name: Cache Pip (macOS x64)
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/pip
          key: ${{ runner.os }}-${{ env.TARGET_ARCH }}-pip-${{ env.PYVERSION }}-${{ hashFiles('**/requirements.txt', '**/setup.py', 'vcpkg.json', 'synthizer-c/vendor.py') }} # Aggiunto vendor.py per coerenza
          restore-keys: |
            ${{ runner.os }}-${{ env.TARGET_ARCH }}-pip-${{ env.PYVERSION }}-

      - name: Setup vcpkg with retry
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: 'vcpkg.json'
          runVcpkgInstall: true
        continue-on-error: true
        
      - name: Retry vcpkg install on failure  
        if: failure()
        timeout-minutes: 45
        run: |
          echo "üîÑ Retrying vcpkg install due to network issues..."
          sleep 30
          
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3..."
            if "$VCPKG_ROOT/vcpkg" install --triplet=$VCPKG_DEFAULT_TRIPLET --feature-flags=versions; then
              echo "‚úÖ vcpkg install succeeded on attempt $i"
              break
            else
              if [ $i -lt 3 ]; then
                echo "‚ùå Attempt $i failed, waiting $(($i * 60)) seconds..."
                sleep $(($i * 60))
              else
                echo "‚ùå All retry attempts failed"
                exit 1
              fi
            fi
          done

      - name: Install dependencies using vcpkg (macOS x64)
        run: |
          echo "VCPKG_ROOT (vcpkg tool directory) is $VCPKG_ROOT"
          echo "VCPKG_DEFAULT_TRIPLET is $VCPKG_DEFAULT_TRIPLET"
          echo "GITHUB_WORKSPACE is $GITHUB_WORKSPACE"

          if [ -z "$VCPKG_ROOT" ]; then
            echo "Error: VCPKG_ROOT is not set."
            exit 1
          fi

          # Se vcpkg.json esiste in $GITHUB_WORKSPACE (CWD), vcpkg installer√† in $GITHUB_WORKSPACE/vcpkg_installed/$VCPKG_DEFAULT_TRIPLET
          "$VCPKG_ROOT/vcpkg" install --triplet "$VCPKG_DEFAULT_TRIPLET"
          echo "Finished vcpkg install command."

          # Percorso di installazione atteso per la modalit√† manifest di vcpkg
          VCPKG_MANIFEST_INSTALL_PATH="$GITHUB_WORKSPACE/vcpkg_installed/$VCPKG_DEFAULT_TRIPLET"
          
          echo "Target CMAKE_PREFIX_PATH will be: $VCPKG_MANIFEST_INSTALL_PATH"
          if [ ! -d "$VCPKG_MANIFEST_INSTALL_PATH" ]; then
            echo "WARNING: Directory $VCPKG_MANIFEST_INSTALL_PATH does NOT exist after vcpkg install."
            echo "This suggests vcpkg did not install to the expected manifest location."
            echo "Listing contents of $GITHUB_WORKSPACE/vcpkg_installed for debugging:"
            ls -la "$GITHUB_WORKSPACE/vcpkg_installed" || echo "$GITHUB_WORKSPACE/vcpkg_installed does not exist or is empty."
            # Verifica anche il percorso classico per completezza di debug
            CLASSIC_INSTALL_PATH="$VCPKG_ROOT/installed/$VCPKG_DEFAULT_TRIPLET"
            echo "Checking classic mode install path for debugging: $CLASSIC_INSTALL_PATH"
            if [ -d "$CLASSIC_INSTALL_PATH" ]; then
                 echo "WARNING: Classic mode path $CLASSIC_INSTALL_PATH EXISTS. This is unexpected if manifest mode is active."
            else
                 echo "Classic mode path $CLASSIC_INSTALL_PATH also does NOT exist."
            fi
          else
            echo "Confirmed: Target directory for CMAKE_PREFIX_PATH exists: $VCPKG_MANIFEST_INSTALL_PATH"
          fi

          echo "CMAKE_PREFIX_PATH=$VCPKG_MANIFEST_INSTALL_PATH" >> "$GITHUB_ENV"
          echo "DYLD_LIBRARY_PATH=$VCPKG_MANIFEST_INSTALL_PATH/lib${DYLD_LIBRARY_PATH:+:$DYLD_LIBRARY_PATH}" >> "$GITHUB_ENV"
          echo "CMAKE_PREFIX_PATH set to $VCPKG_MANIFEST_INSTALL_PATH"
          echo "DYLD_LIBRARY_PATH extended with $VCPKG_MANIFEST_INSTALL_PATH/lib"

      - name: Install Python build dependencies (macOS)
        run: |
          python -m pip install --upgrade pip
          pip install ninja cmake wheel tomli setuptools packaging distro scikit-build cython build delocate

      - name: Build Python Wheels (macOS x64)
        run: |
          echo "Building with CMAKE_PREFIX_PATH = $CMAKE_PREFIX_PATH"
          echo "Current DYLD_LIBRARY_PATH for build = $DYLD_LIBRARY_PATH"
          python -m build --wheel --no-isolation
      - name: Repair Wheel with Delocate (macOS x64)
        run: |
          # Definisci il percorso delle librerie vcpkg
          VCPKG_LIB_PATH="$GITHUB_WORKSPACE/vcpkg_installed/$VCPKG_DEFAULT_TRIPLET/lib"
          
          echo "üìÇ Using vcpkg library path: $VCPKG_LIB_PATH"
          
          # Verifica che il percorso esista
          if [ ! -d "$VCPKG_LIB_PATH" ]; then
            echo "‚ùå vcpkg lib directory not found: $VCPKG_LIB_PATH"
            echo "üîç Searching for actual lib directory..."
            find "$GITHUB_WORKSPACE/vcpkg_installed" -name "lib" -type d | head -5
            
            # Fallback: usa il percorso trovato dinamicamente nel step precedente
            if [ -n "$CMAKE_PREFIX_PATH" ]; then
              VCPKG_LIB_PATH="$CMAKE_PREFIX_PATH/lib"
              echo "üîÑ Trying fallback path: $VCPKG_LIB_PATH"
            fi
            
            if [ ! -d "$VCPKG_LIB_PATH" ]; then
              echo "‚ùå Still no lib directory found, exiting"
              exit 1
            fi
          fi
          
          echo "üîç Available libraries in vcpkg:"
          ls -la "$VCPKG_LIB_PATH" | grep -E "\.(dylib|a)$" | head -10 || echo "No libraries found"
          
          # Aggiungi il percorso vcpkg alle variabili d'ambiente per delocate
          export DYLD_LIBRARY_PATH="$VCPKG_LIB_PATH:$DYLD_LIBRARY_PATH"
          
          # Check wheel dependencies before repair
          for wheel in dist/*.whl; do
            if [ -f "$wheel" ]; then
              echo "üîç Analyzing wheel dependencies before repair: $wheel"
              delocate-listdeps "$wheel" || echo "Could not list dependencies"
            fi
          done
          
          for wheel in dist/*.whl; do
            echo "üîß Repairing wheel: $wheel"
            # Usa -L per specificare dove cercare le librerie
            delocate-wheel \
              -L "$VCPKG_LIB_PATH" \
              -w dist/ \
              -v \
              "$wheel"
          done
          
          echo "‚úÖ Repaired wheels:"
          ls -l dist/
      - name: Upload Python Wheel Artifact (macOS x64)
        uses: actions/upload-artifact@v4
        with:
          name: python-wheels-macos-x64-${{ matrix.PYVERSION }}
          path: dist/*.whl
          if-no-files-found: error # Aggiunto per fallire se non ci sono wheel

  # Job per costruire le wheel su macOS (ARM64 - ARM Runner)
  macos-arm64-build:
    name: Build macOS (arm64) Python ${{ matrix.PYVERSION }}
    runs-on: macos-latest # Dovrebbe selezionare un runner ARM (es. macos-14)
    env:
      PYVERSION: ${{ matrix.PYVERSION }}
      TARGET_ARCH: "arm64"
      VCPKG_DEFAULT_TRIPLET: "arm64-osx"
    strategy:
      fail-fast: false
      matrix:
        PYVERSION: ["3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python ${{ matrix.PYVERSION }} (arm64)
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.PYVERSION }}
          architecture: 'arm64' # Assicura Python arm64

      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      - name: Run C/C++ code vendoring script
        run: python synthizer-c/vendor.py synthizer-vendored

      - name: Cache Pip (macOS arm64)
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/pip
          key: ${{ runner.os }}-${{ env.TARGET_ARCH }}-pip-${{ env.PYVERSION }}-${{ hashFiles('**/requirements.txt', '**/setup.py', 'vcpkg.json', 'synthizer-c/vendor.py') }} # Aggiunto vendor.py per coerenza
          restore-keys: |
            ${{ runner.os }}-${{ env.TARGET_ARCH }}-pip-${{ env.PYVERSION }}-

      - name: Setup vcpkg with retry
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: 'vcpkg.json'
          runVcpkgInstall: true
        continue-on-error: true
        
      - name: Retry vcpkg install on failure
        if: failure()
        timeout-minutes: 45
        run: |
          echo "üîÑ Retrying vcpkg install due to network issues..."
          sleep 30
          
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3..."
            if "$VCPKG_ROOT/vcpkg" install --triplet=$VCPKG_DEFAULT_TRIPLET --feature-flags=versions; then
              echo "‚úÖ vcpkg install succeeded on attempt $i"
              break
            else
              if [ $i -lt 3 ]; then
                echo "‚ùå Attempt $i failed, waiting $(($i * 60)) seconds..."
                sleep $(($i * 60))
              else
                echo "‚ùå All retry attempts failed"
                exit 1
              fi
            fi
          done

      - name: Install dependencies using vcpkg (macOS arm64)
        run: |
          echo "VCPKG_ROOT (vcpkg tool directory) is $VCPKG_ROOT"
          echo "VCPKG_DEFAULT_TRIPLET is $VCPKG_DEFAULT_TRIPLET"
          echo "GITHUB_WORKSPACE is $GITHUB_WORKSPACE"

          if [ -z "$VCPKG_ROOT" ]; then
            echo "Error: VCPKG_ROOT is not set."
            exit 1
          fi

          # Se vcpkg.json esiste in $GITHUB_WORKSPACE (CWD), vcpkg installer√† in $GITHUB_WORKSPACE/vcpkg_installed/$VCPKG_DEFAULT_TRIPLET
          "$VCPKG_ROOT/vcpkg" install --triplet "$VCPKG_DEFAULT_TRIPLET"
          echo "Finished vcpkg install command."

          # Percorso di installazione atteso per la modalit√† manifest di vcpkg
          VCPKG_MANIFEST_INSTALL_PATH="$GITHUB_WORKSPACE/vcpkg_installed/$VCPKG_DEFAULT_TRIPLET"
          
          echo "Target CMAKE_PREFIX_PATH will be: $VCPKG_MANIFEST_INSTALL_PATH"
          if [ ! -d "$VCPKG_MANIFEST_INSTALL_PATH" ]; then
            echo "WARNING: Directory $VCPKG_MANIFEST_INSTALL_PATH does NOT exist after vcpkg install."
            echo "This suggests vcpkg did not install to the expected manifest location."
            echo "Listing contents of $GITHUB_WORKSPACE/vcpkg_installed for debugging:"
            ls -la "$GITHUB_WORKSPACE/vcpkg_installed" || echo "$GITHUB_WORKSPACE/vcpkg_installed does not exist or is empty."
            CLASSIC_INSTALL_PATH="$VCPKG_ROOT/installed/$VCPKG_DEFAULT_TRIPLET"
            echo "Checking classic mode install path for debugging: $CLASSIC_INSTALL_PATH"
            if [ -d "$CLASSIC_INSTALL_PATH" ]; then
                 echo "WARNING: Classic mode path $CLASSIC_INSTALL_PATH EXISTS. This is unexpected if manifest mode is active."
            else
                 echo "Classic mode path $CLASSIC_INSTALL_PATH also does NOT exist."
            fi
          else
            echo "Confirmed: Target directory for CMAKE_PREFIX_PATH exists: $VCPKG_MANIFEST_INSTALL_PATH"
          fi
          
          echo "CMAKE_PREFIX_PATH=$VCPKG_MANIFEST_INSTALL_PATH" >> "$GITHUB_ENV"
          echo "DYLD_LIBRARY_PATH=$VCPKG_MANIFEST_INSTALL_PATH/lib${DYLD_LIBRARY_PATH:+:$DYLD_LIBRARY_PATH}" >> "$GITHUB_ENV"
          echo "CMAKE_PREFIX_PATH set to $VCPKG_MANIFEST_INSTALL_PATH"
          echo "DYLD_LIBRARY_PATH extended with $VCPKG_MANIFEST_INSTALL_PATH/lib"

      - name: Install Python build dependencies (macOS)
        run: |
          python -m pip install --upgrade pip
          pip install ninja cmake wheel tomli setuptools packaging distro scikit-build cython build delocate

      - name: Build Python Wheels (macOS arm64)
        run: |
          echo "Building with CMAKE_PREFIX_PATH = $CMAKE_PREFIX_PATH"
          echo "Current DYLD_LIBRARY_PATH for build = $DYLD_LIBRARY_PATH"
          python -m build --wheel --no-isolation
      - name: Repair Wheel with Delocate (macOS arm64)
        run: |
          # Definisci il percorso delle librerie vcpkg
          VCPKG_LIB_PATH="$GITHUB_WORKSPACE/vcpkg_installed/$VCPKG_DEFAULT_TRIPLET/lib"
          
          echo "üìÇ Using vcpkg library path: $VCPKG_LIB_PATH"
          
          # Verifica che il percorso esista
          if [ ! -d "$VCPKG_LIB_PATH" ]; then
            echo "‚ùå vcpkg lib directory not found: $VCPKG_LIB_PATH"
            echo "üîç Searching for actual lib directory..."
            find "$GITHUB_WORKSPACE/vcpkg_installed" -name "lib" -type d | head -5
            
            # Fallback: usa il percorso trovato dinamicamente nel step precedente
            if [ -n "$CMAKE_PREFIX_PATH" ]; then
              VCPKG_LIB_PATH="$CMAKE_PREFIX_PATH/lib"
              echo "üîÑ Trying fallback path: $VCPKG_LIB_PATH"
            fi
            
            if [ ! -d "$VCPKG_LIB_PATH" ]; then
              echo "‚ùå Still no lib directory found, exiting"
              exit 1
            fi
          fi
          
          echo "üîç Available libraries in vcpkg:"
          ls -la "$VCPKG_LIB_PATH" | grep -E "\.(dylib|a)$" | head -10 || echo "No libraries found"
          
          # Aggiungi il percorso vcpkg alle variabili d'ambiente per delocate
          export DYLD_LIBRARY_PATH="$VCPKG_LIB_PATH:$DYLD_LIBRARY_PATH"
          
          # Check wheel dependencies before repair
          for wheel in dist/*.whl; do
            if [ -f "$wheel" ]; then
              echo "üîç Analyzing wheel dependencies before repair: $wheel"
              delocate-listdeps "$wheel" || echo "Could not list dependencies"
            fi
          done
          
          for wheel in dist/*.whl; do
            echo "üîß Repairing wheel: $wheel"
            # Usa -L per specificare dove cercare le librerie
            delocate-wheel \
              -L "$VCPKG_LIB_PATH" \
              -w dist/ \
              -v \
              "$wheel"
          done
          
          echo "‚úÖ Repaired wheels:"
          ls -l dist/
      - name: Upload Python Wheel Artifact (macOS arm64)
        uses: actions/upload-artifact@v4
        with:
          name: python-wheels-macos-arm64-${{ matrix.PYVERSION }}
          path: dist/*.whl
          if-no-files-found: error # Aggiunto per fallire se non ci sono wheel

  # Job per il deployment su PyPI
  deploy_pypi:
    name: Deploy to PyPI
    needs: [windows-build, linux-x64-build, macos-x64-build, macos-arm64-build]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Required for trusted publishing
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ~/artifacts
          # pattern: python-wheels-* # Optional: if you need to be specific, otherwise downloads all
          # merge-multiple: true # If artifacts have same names from different jobs (not the case here)

      - name: Set up Python for Twine
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Upgrade pip for Twine step
        run: python -m pip install --upgrade pip

      - name: Install Twine
        run: python -m pip install --upgrade twine

      - name: Display downloaded artifacts structure
        run: ls -R ~/artifacts

      - name: Upload to PyPI
        run: |
          python -m twine upload --skip-existing ~/artifacts/*/*.whl