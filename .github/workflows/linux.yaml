# Synthizer3D v0.9.1 - ManyLinux Python Wheels Build Workflow
# Questo workflow compila wheel Python manylinux compatibili per Synthizer3D,
# una libreria audio 3D. Include tutte le dipendenze audio (Opus, Vorbis, FAAD2)
# e supporta sia architetture x86_64 che i686.
# Versione: 1.0.0 (Finale)
# Ultimo aggiornamento: Giugno 2025
# Autore: Assistant & Team Synthizer3D

name: Build and Publish Python Wheels for ManyLinux

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 0.9.1)'
        required: true
        default: '0.9.1'
      upload_to_pypi:
        description: 'Upload to PyPI (true/false)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  # CORREZIONE: Usiamo il nuovo sistema di cache 'gits'
  VCPKG_BINARY_SOURCES: "clear;gits,readwrite"
  SYNTHIZER_VERSION: ${{ github.event.inputs.version || '0.9.1' }}

jobs:
  build-manylinux:
    runs-on: ubuntu-latest
    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        include:
          # x86_64 builds
          - CI_ARCH: x86_64
            VCPKG_TRIPLET: x64-linux
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: '3.8'
          - CI_ARCH: x86_64
            VCPKG_TRIPLET: x64-linux
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: '3.9'
          - CI_ARCH: x86_64
            VCPKG_TRIPLET: x64-linux
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: '3.10'
          - CI_ARCH: x86_64
            VCPKG_TRIPLET: x64-linux
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: '3.11'
          - CI_ARCH: x86_64
            VCPKG_TRIPLET: x64-linux
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: '3.12'
          - CI_ARCH: x86_64
            VCPKG_TRIPLET: x64-linux
            MANYLINUX_VERSION: manylinux_2_28
            PYVERSION: '3.13'
          # i686 builds
          - CI_ARCH: i686
            VCPKG_TRIPLET: x86-linux
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: '3.8'
          - CI_ARCH: i686
            VCPKG_TRIPLET: x86-linux
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: '3.9'
          - CI_ARCH: i686
            VCPKG_TRIPLET: x86-linux
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: '3.10'
          - CI_ARCH: i686
            VCPKG_TRIPLET: x86-linux
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: '3.11'
          - CI_ARCH: i686
            VCPKG_TRIPLET: x86-linux
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: '3.12'
          - CI_ARCH: i686
            VCPKG_TRIPLET: x86-linux
            MANYLINUX_VERSION: manylinux2014
            PYVERSION: '3.13'

    name: "Build ManyLinux (${{ matrix.CI_ARCH }}, ${{ matrix.MANYLINUX_VERSION }}) Python ${{ matrix.PYVERSION }}"

    container:
      image: quay.io/pypa/${{ matrix.MANYLINUX_VERSION }}_${{ matrix.CI_ARCH }}
      options: --user root

    env:
      CI_ARCH: ${{ matrix.CI_ARCH }}
      MANYLINUX_VERSION: ${{ matrix.MANYLINUX_VERSION }}
      PYVERSION: ${{ matrix.PYVERSION }}
      # CORREZIONE: Impostiamo il triplet corretto per ogni architettura
      VCPKG_DEFAULT_TRIPLET: ${{ matrix.VCPKG_TRIPLET }}
      EFFECTIVE_VCPKG_INSTALLED_DIR_BASE: ${{ github.workspace }}/vcpkg_installed

    steps:
      # 1. Checkout del codice (condizionale per architettura)
      - name: Checkout source code (for 64-bit jobs)
        if: matrix.CI_ARCH == 'x86_64'
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Checkout source code with git (for 32-bit jobs)
        if: matrix.CI_ARCH == 'i686'
        run: |
          git config --global --add safe.directory "*"
          git clone https://github.com/${{ github.repository }}.git .
          git checkout ${{ github.sha }}
          git submodule update --init --recursive
      
      # 2. Impostazione del percorso di Python
      - name: Set environment variables for Python path
        run: |
          echo "üêç Setting up Python ${{ matrix.PYVERSION }} environment..."
          if [ "${{ matrix.PYVERSION }}" = "3.8" ]; then echo "PYTHON_PATH=/opt/python/cp38-cp38" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.9" ]; then echo "PYTHON_PATH=/opt/python/cp39-cp39" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.10" ]; then echo "PYTHON_PATH=/opt/python/cp310-cp310" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.11" ]; then echo "PYTHON_PATH=/opt/python/cp311-cp311" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.12" ]; then echo "PYTHON_PATH=/opt/python/cp312-cp312" >> $GITHUB_ENV
          elif [ "${{ matrix.PYVERSION }}" = "3.13" ]; then echo "PYTHON_PATH=/opt/python/cp313-cp313" >> $GITHUB_ENV
          fi

      # 3. Installazione di tutte le dipendenze (di sistema e di Python)
      - name: Install system and Python build dependencies
        timeout-minutes: 10
        run: |
          echo "üì¶ Installing system dependencies..."
          if command -v dnf >/dev/null 2>&1; then
            dnf install -y curl zip unzip tar cmake make gcc-c++
          elif command -v yum >/dev/null 2>&1; then
            yum install -y curl zip unzip tar cmake make gcc-c++
          fi
          
          echo "üì¶ Installing Python build tools (including ninja)..."
          $PYTHON_PATH/bin/python -m pip install --upgrade pip
          $PYTHON_PATH/bin/pip install ninja cmake wheel tomli setuptools packaging distro scikit-build cython build auditwheel twine

      # 4. Setup di vcpkg
      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: 'vcpkg.json'
          runVcpkgInstall: false
      
      # 5. Installazione delle librerie audio con vcpkg
      - name: Install vcpkg audio dependencies (Opus, Vorbis, FAAD2)
        timeout-minutes: 25
        run: |
          echo "üéµ Installing audio libraries via vcpkg..."
          cd synthizer-c
          "$VCPKG_ROOT/vcpkg" install --triplet=$VCPKG_DEFAULT_TRIPLET --feature-flags=versions
          echo "Setting CMAKE_PREFIX_PATH and library paths..."
          TARGET_CMAKE_PREFIX_PATH="${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/$VCPKG_DEFAULT_TRIPLET"
          echo "CMAKE_PREFIX_PATH=$TARGET_CMAKE_PREFIX_PATH" >> $GITHUB_ENV
          echo "LD_LIBRARY_PATH=$TARGET_CMAKE_PREFIX_PATH/lib:$LD_LIBRARY_PATH" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$TARGET_CMAKE_PREFIX_PATH/lib/pkgconfig:$PKG_CONFIG_PATH" >> $GITHUB_ENV

      # ... (tutti gli altri step da "Set version in setup.py" in poi rimangono identici)
      # ... (copia e incolla il resto del tuo file da qui in poi)
      
      - name: Set version in setup.py and pyproject.toml
        # ...

      - name: Run C/C++ code vendoring script
        # ...
        
      - name: Fix C++ compilation issues for modern compilers
        # ...

      - name: Build Python Wheels (ManyLinux ${{ matrix.CI_ARCH }})
        # ...

      - name: Repair wheels with auditwheel (make manylinux compatible)
        # ...

      - name: Upload wheel artifacts
        # ...

  # Il resto dei job (publish-to-pypi, build-summary) rimane invariato
  publish-to-pypi:
    # ...
  
  build-summary:
    # ...
      - name: Set version in setup.py and pyproject.toml
        run: |
          echo "üè∑Ô∏è Setting version to: ${{ env.SYNTHIZER_VERSION }}"
          
          # Aggiorna version in setup.py se esiste
          if [ -f "setup.py" ]; then
            sed -i "s/version=['\"][^'\"]*['\"]/version='${{ env.SYNTHIZER_VERSION }}'/g" setup.py
            echo "‚úÖ Updated setup.py with version ${{ env.SYNTHIZER_VERSION }}"
          fi
          
          # Aggiorna version in pyproject.toml se esiste
          if [ -f "pyproject.toml" ]; then
            sed -i "s/version = ['\"][^'\"]*['\"]/version = \"${{ env.SYNTHIZER_VERSION }}\"/g" pyproject.toml
            echo "‚úÖ Updated pyproject.toml with version ${{ env.SYNTHIZER_VERSION }}"
          fi
          
          # Verifica le modifiche
          echo "=== Current setup.py version line ==="
          grep -n "version" setup.py || echo "No version found in setup.py"
          echo "=== Current pyproject.toml version line ==="
          grep -n "version" pyproject.toml || echo "No version found in pyproject.toml"
      - name: Run C/C++ code vendoring script
        timeout-minutes: 5
        run: |
          echo "üìÅ Running Synthizer vendoring script..."
          $PYTHON_PATH/bin/python synthizer-c/vendor.py synthizer-vendored

      - name: Fix C++ compilation issues for modern compilers
        run: |
          echo "üîß Fixing C++20 template-id constructor issues..."
          
          # Fix nel file property_automation_timeline.hpp
          if [ -f "synthizer-vendored/include/synthizer/property_automation_timeline.hpp" ]; then
            sed -i 's/PropertyAutomationPoint<N>(const PropertyAutomationPoint<N> &) = default;/PropertyAutomationPoint(const PropertyAutomationPoint<N> \&) = default;/g' \
              synthizer-vendored/include/synthizer/property_automation_timeline.hpp
            echo "‚úÖ Fixed PropertyAutomationPoint constructor"
          fi
          
          # Fix per il cast di funzioni in mp3.hpp
          if [ -f "synthizer-vendored/include/synthizer/decoders/mp3.hpp" ]; then
            # Cercare il cast problematico e sostituirlo
            sed -i 's/local_seek_cb_for_init = (drmp3_seek_proc)seek_cb;/local_seek_cb_for_init = reinterpret_cast<drmp3_seek_proc>(seek_cb);/g' \
              synthizer-vendored/include/synthizer/decoders/mp3.hpp
            echo "‚úÖ Fixed function cast in mp3.hpp"
          fi
          
          # Disabilita -Werror nei CMakeLists.txt se presente
          find synthizer-vendored -name "CMakeLists.txt" -exec sed -i 's/-Werror//g' {} \;
          find synthizer-vendored -name "*.cmake" -exec sed -i 's/-Werror//g' {} \;
          
          echo "‚úÖ C++ fixes applied"

      - name: Build Python Wheels (ManyLinux ${{ matrix.CI_ARCH }})
        timeout-minutes: 20
        env:
          # CMAKE_PREFIX_PATH √® impostato tramite GITHUB_ENV
          SYNTHIZER_EXPECTED_VCPKG_PATH_FOR_DEBUG: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/${{ env.VCPKG_DEFAULT_TRIPLET }}
          # Flag per risolvere errori di compilazione C++
          CXXFLAGS: "-Wno-template-id-cdtor -Wno-cast-function-type -Wno-error"
          CFLAGS: "-Wno-error"
        run: |
          echo "üî® Building Synthizer3D wheel for $CI_ARCH..."
          cd "$GITHUB_WORKSPACE"
          echo "Architecture: $CI_ARCH"
          echo "ManyLinux version: $MANYLINUX_VERSION"
          echo "Current CMAKE_PREFIX_PATH for build is: $CMAKE_PREFIX_PATH"
          echo "EFFECTIVE_VCPKG_INSTALLED_DIR_BASE for build is: $EFFECTIVE_VCPKG_INSTALLED_DIR_BASE"
          echo "Synthizer expects vcpkg path (for debug/verification): $SYNTHIZER_EXPECTED_VCPKG_PATH_FOR_DEBUG"
          echo "Current LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
          echo "Current PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          echo "CXXFLAGS: $CXXFLAGS"
          echo "CFLAGS: $CFLAGS"
          
          $PYTHON_PATH/bin/python -m build --wheel --no-isolation
          echo "‚úÖ Wheel built successfully!"

      - name: Debug vcpkg installation
        run: |
          echo "üîç Debugging vcpkg installation..."
          VCPKG_INSTALLED_TRIPLET_DIR="$EFFECTIVE_VCPKG_INSTALLED_DIR_BASE/$VCPKG_DEFAULT_TRIPLET"
          echo "Listing contents of effective vcpkg directory: $VCPKG_INSTALLED_TRIPLET_DIR ..."
          if [ -d "$VCPKG_INSTALLED_TRIPLET_DIR" ]; then
            find "$VCPKG_INSTALLED_TRIPLET_DIR" -maxdepth 3 -type f -exec ls -la {} \; | head -50
          else
            echo "WARNING: $VCPKG_INSTALLED_TRIPLET_DIR does not exist."
          fi
          
          VCPKG_INSTALLED_LIB_DIR="$VCPKG_INSTALLED_TRIPLET_DIR/lib"
          if [ -d "$VCPKG_INSTALLED_LIB_DIR" ]; then
            echo "Listing contents of $VCPKG_INSTALLED_LIB_DIR ..."
            ls -la "$VCPKG_INSTALLED_LIB_DIR"
          else
            echo "WARNING: $VCPKG_INSTALLED_LIB_DIR does not exist or is not a directory."
          fi
          
          VCPKG_INSTALLED_BIN_DIR="$VCPKG_INSTALLED_TRIPLET_DIR/bin"
          if [ -d "$VCPKG_INSTALLED_BIN_DIR" ]; then
            echo "Listing contents of $VCPKG_INSTALLED_BIN_DIR ..."
            ls -la "$VCPKG_INSTALLED_BIN_DIR"
          else
            echo "WARNING: $VCPKG_INSTALLED_BIN_DIR does not exist or is not a directory."
          fi

      - name: Repair wheels with auditwheel (make manylinux compatible)
        timeout-minutes: 10
        env:
          VCPKG_INSTALLED_TRIPLET_DIR: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/${{ env.VCPKG_DEFAULT_TRIPLET }}
          VCPKG_INSTALLED_LIB_DIR: ${{ env.EFFECTIVE_VCPKG_INSTALLED_DIR_BASE }}/${{ env.VCPKG_DEFAULT_TRIPLET }}/lib
        run: |
          echo "üõ†Ô∏è Repairing wheels with auditwheel..."
          echo "Path vcpkg (lib) che sar√† aggiunto a auditwheel: $VCPKG_INSTALLED_LIB_DIR"
          
          # Crea directory wheelhouse se non esiste
          mkdir -p wheelhouse
          
          for wheel in dist/*.whl; do
            if [ -f "$wheel" ]; then
              echo "Repairing wheel: $wheel"
              # Usa auditwheel per riparare la wheel e renderla compatibile con manylinux
              # Sintassi corretta: repair prima di --plat-tag
              $PYTHON_PATH/bin/auditwheel repair \
                "$wheel" \
                --plat "${MANYLINUX_VERSION}_${CI_ARCH}" \
                --wheel-dir wheelhouse
            fi
          done
          
          echo "Listing repaired wheels in wheelhouse/:"
          ls -la wheelhouse/*.whl || echo "No wheels found in wheelhouse/"
          
          # Sposta le wheel riparate in dist/ per coerenza con gli altri job
          if ls wheelhouse/*.whl 1> /dev/null 2>&1; then
            cp wheelhouse/*.whl dist/
            echo "‚úÖ Copied repaired wheels to dist/:"
            ls -la dist/*.whl
          fi

      - name: Verify wheel contents and metadata
        run: |
          echo "üîç Verifying wheel contents..."
          for wheel in dist/*.whl; do
            if [ -f "$wheel" ]; then
              echo "=== Wheel: $wheel ==="
              $PYTHON_PATH/bin/python -m zipfile -l "$wheel" | head -20
              echo ""
              # Verifica metadata con auditwheel
              echo "=== Auditwheel show output ==="
              $PYTHON_PATH/bin/auditwheel show "$wheel" || echo "Auditwheel show failed"
              echo ""
            fi
          done

      - name: Upload wheel artifacts
        uses: actions/upload-artifact@v4
        timeout-minutes: 5
        with:
          name: python-wheels-${{ matrix.MANYLINUX_VERSION }}-${{ matrix.CI_ARCH }}-py${{ matrix.PYVERSION }}
          path: dist/*.whl

  # Job separato per la pubblicazione (solo quando richiesto)
  publish-to-pypi:
    needs: build-manylinux
    runs-on: ubuntu-latest
    if: >
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.upload_to_pypi == 'true')
    
    environment:
      name: pypi
      url: https://pypi.org/p/synthizer3d

    permissions:
      id-token: write  # Per PyPI trusted publishing
      
    steps:
      - name: Download all wheel artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: python-wheels-*
          path: dist
          merge-multiple: true

      - name: List all wheels to be published
        run: |
          echo "üéØ Wheels ready for publication:"
          ls -la dist/*.whl
          echo ""
          echo "Total wheels: $(ls dist/*.whl | wc -l)"

      - name: Publish to Test PyPI (for testing)
        if: github.event_name == 'workflow_dispatch'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          packages-dir: dist/
          verbose: true

      - name: Publish to PyPI (production)
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/
          verbose: true

  # Job finale per summary
  build-summary:
    needs: build-manylinux
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Build Summary
        run: |
          echo "# üéµ Synthizer3D v${{ env.SYNTHIZER_VERSION }} Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build Matrix Results" >> $GITHUB_STEP_SUMMARY
          echo "- **x86_64 wheels**: 5 versions (Python 3.8-3.12) with manylinux_2_28" >> $GITHUB_STEP_SUMMARY
          echo "- **i686 wheels**: 5 versions (Python 3.8-3.12) with manylinux2014" >> $GITHUB_STEP_SUMMARY
          echo "- **Total expected wheels**: 10" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Audio Libraries Included" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **Opus**: Advanced audio codec" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **Vorbis**: OGG Vorbis audio codec" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **FAAD2**: AAC audio decoder" >> $GITHUB_STEP_SUMMARY
          echo "- üéµ **OGG**: Container format support" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.build-manylinux.result }}" = "success" ]; then
            echo "‚úÖ **Build Status**: SUCCESS" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Build Status**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi
 