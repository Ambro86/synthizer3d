# Workflow for Synthizer3d
# by Ambro86, adapted for cibuildwheel
name: Build Synthizer3d Wheels and Sdist

on:
  push: {}
  pull_request: {}

jobs:
  build_wheels:
    name: Build Wheels on ${{ matrix.os }} (${{ matrix.arch_label }})
    runs-on: ${{ matrix.os }}
    permissions:
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            arch_label: x64_aarch64
            cibw_archs: "x86_64 aarch64"
            vcpkg_triplet_map_x86_64: "x64-linux"
            vcpkg_triplet_map_aarch64: "aarch64-linux"
            is_linux: true
          - os: windows-latest
            arch_label: x86_amd64
            cibw_archs: "x86 AMD64" 
            vcpkg_triplet_map_x86: "x86-windows"
            vcpkg_triplet_map_amd64: "x64-windows"
            msvc_dev_cmd_arch: "x64" # Architettura host per msvc-dev-cmd
            is_windows: true
          - os: macos-13 
            arch_label: x64
            cibw_archs: "x86_64"
            vcpkg_triplet_map_x86_64: "x64-osx"
            is_macos: true
          - os: macos-14 
            arch_label: arm64
            cibw_archs: "arm64"
            vcpkg_triplet_map_arm64: "arm64-osx"
            is_macos: true

    steps:
      - name: Ensure /usr/bin is in PATH for macOS
        if: matrix.is_macos == true
        run: echo "/usr/bin" >> $GITHUB_PATH

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Run C/C++ code vendoring script
        run: python synthizer-c/vendor.py synthizer-vendored

      - name: Determine vcpkg triplet for primary architecture of the job
        id: vcpkg_triplet_primary
        shell: bash
        run: |
          TRIPLET=""
          if [ "${{ matrix.is_windows }}" == "true" ]; then
            TRIPLET="${{ matrix.vcpkg_triplet_map_amd64 }}" # Host/default for Windows job is x64
          elif [ "${{ matrix.is_linux }}" == "true" ]; then
            if [[ "${{ matrix.cibw_archs }}" == *"x86_64"* ]]; then
              TRIPLET="${{ matrix.vcpkg_triplet_map_x86_64 }}"
            elif [[ "${{ matrix.cibw_archs }}" == *"aarch64"* ]]; then
              TRIPLET="${{ matrix.vcpkg_triplet_map_aarch64 }}"
            fi
          elif [ "${{ matrix.is_macos }}" == "true" ]; then
            if [[ "${{ matrix.cibw_archs }}" == "x86_64" ]]; then
              TRIPLET="${{ matrix.vcpkg_triplet_map_x86_64 }}"
            elif [[ "${{ matrix.cibw_archs }}" == "arm64" ]]; then
              TRIPLET="${{ matrix.vcpkg_triplet_map_arm64 }}"
            fi
          fi
          if [ -z "$TRIPLET" ]; then
            echo "::error::Impossibile determinare PRIMARY_VCPKG_TRIPLET per os=${{ matrix.os }}, cibw_archs='${{ matrix.cibw_archs }}'"
            exit 1
          fi
          echo "PRIMARY_VCPKG_TRIPLET=$TRIPLET" >> $GITHUB_ENV
          echo "Determinato PRIMARY_VCPKG_TRIPLET per il job (default/host): $TRIPLET"

      # Per Windows, configura l'ambiente MSVC PRIMA di vcpkg e cibuildwheel
      - name: Setup MSVC Developer Command Prompt (Windows only)
        if: matrix.is_windows == true
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.msvc_dev_cmd_arch }}
          # Questa azione aggiorna l'ambiente dello step, inclusi INCLUDE, LIB, PATH

      - name: Set up vcpkg (bootstrap only)
        uses: lukka/run-vcpkg@v11.5
        env:
          VCPKG_DEFAULT_TRIPLET: ${{ env.PRIMARY_VCPKG_TRIPLET }} # Triplet di default per bootstrap
        with:
          runVcpkgInstall: false # Installeremo i pacchetti manualmente

      - name: Install vcpkg packages and set default paths
        shell: bash
        run: |
          echo "VCPKG_ROOT (from lukka/run-vcpkg) is $VCPKG_ROOT"
          EFFECTIVE_TRIPLET_FOR_DEFAULT_PATHS="${{ env.PRIMARY_VCPKG_TRIPLET }}"

          if [ "${{ matrix.is_windows }}" == "true" ]; then
            echo "Installando vcpkg packages per ${{ matrix.vcpkg_triplet_map_x86 }}"
            "$VCPKG_ROOT/vcpkg" install --triplet "${{ matrix.vcpkg_triplet_map_x86 }}"
            echo "Installando vcpkg packages per ${{ matrix.vcpkg_triplet_map_amd64 }}"
            "$VCPKG_ROOT/vcpkg" install --triplet "${{ matrix.vcpkg_triplet_map_amd64 }}"
            # Per GITHUB_ENV e GITHUB_PATH, usiamo il triplet primario (AMD64) come default.
            # CIBW_ENVIRONMENT_WINDOWS sovrascriverà dinamicamente per ogni architettura.
          elif [ "${{ matrix.is_linux }}" == "true" ] || [ "${{ matrix.is_macos }}" == "true" ]; then
            echo "Installando vcpkg packages per ${{ env.PRIMARY_VCPKG_TRIPLET }}"
            "$VCPKG_ROOT/vcpkg" install --triplet "${{ env.PRIMARY_VCPKG_TRIPLET }}"
          else
            echo "::error::OS non supportato per lo script di installazione vcpkg."
            exit 1
          fi
          
          # Imposta un VCPKG_INSTALLED_DIR_PATH_FOR_CIBW di default (basato sul triplet primario)
          # Questo sarà usato da Linux/macOS e come fallback se non sovrascritto.
          VCPKG_INSTALLED_DIR_FOR_JOB_DEFAULT="$VCPKG_ROOT/installed/$EFFECTIVE_TRIPLET_FOR_DEFAULT_PATHS"
          VCPKG_INSTALLED_DIR_PATH_FOR_CIBW_UNIX_STYLE_DEFAULT=$(echo "$VCPKG_INSTALLED_DIR_FOR_JOB_DEFAULT" | sed 's_\\_/_g')
          
          echo "VCPKG_INSTALLED_DIR_PATH_FOR_CIBW=$VCPKG_INSTALLED_DIR_PATH_FOR_CIBW_UNIX_STYLE_DEFAULT" >> $GITHUB_ENV
          echo "Set VCPKG_INSTALLED_DIR_PATH_FOR_CIBW (default) to $VCPKG_INSTALLED_DIR_PATH_FOR_CIBW_UNIX_STYLE_DEFAULT"

          # Aggiungi i percorsi vcpkg (del triplet primario) a GITHUB_PATH per disponibilità generale degli strumenti
          VCPKG_BIN_DIR_UNIX_STYLE_DEFAULT="$VCPKG_INSTALLED_DIR_PATH_FOR_CIBW_UNIX_STYLE_DEFAULT/bin"
          VCPKG_TOOLS_TRIPLET_DIR_UNIX_STYLE_DEFAULT="$VCPKG_INSTALLED_DIR_PATH_FOR_CIBW_UNIX_STYLE_DEFAULT/tools/$EFFECTIVE_TRIPLET_FOR_DEFAULT_PATHS/bin"
          
          echo "Adding to GITHUB_PATH (default): $VCPKG_BIN_DIR_UNIX_STYLE_DEFAULT"
          echo "$VCPKG_BIN_DIR_UNIX_STYLE_DEFAULT" >> $GITHUB_PATH
          echo "Adding to GITHUB_PATH (default): $VCPKG_TOOLS_TRIPLET_DIR_UNIX_STYLE_DEFAULT"
          echo "$VCPKG_TOOLS_TRIPLET_DIR_UNIX_STYLE_DEFAULT" >> $GITHUB_PATH
          
          if [ "${{ matrix.is_windows }}" == "true" ]; then
            echo "LD_LIBRARY_PATH_FOR_CIBW=" >> $GITHUB_ENV # Non usato su Windows, PATH è preferito
          else
            echo "LD_LIBRARY_PATH_FOR_CIBW=$VCPKG_INSTALLED_DIR_PATH_FOR_CIBW_UNIX_STYLE_DEFAULT/lib" >> $GITHUB_ENV
          fi
          echo "Paths set for subsequent steps (default GITHUB_ENV values). Current GITHUB_PATH:"
          cat $GITHUB_PATH

      - name: Create Windows repair script
        if: matrix.is_windows == true
        shell: bash 
        run: |
          mkdir -p .github/workflows
          cat << 'EOF' > .github/workflows/repair_wheel_windows.py
          import os
          import sys
          import subprocess
          import pathlib

          if __name__ == "__main__":
              wheel_file_path_str = sys.argv[1]
              dest_dir_str = sys.argv[2]
              # Questa variabile sarà impostata dinamicamente da CIBW_ENVIRONMENT_WINDOWS
              vcpkg_installed_raw = os.environ.get('VCPKG_INSTALLED_DIR_PATH_FOR_CIBW') 
              if not vcpkg_installed_raw:
                  print(f"::error::Variabile d'ambiente VCPKG_INSTALLED_DIR_PATH_FOR_CIBW non impostata per lo script di riparazione.")
                  sys.exit(1)
              
              # pathlib gestirà correttamente sia path Windows che Unix-style emulati
              vcpkg_installed_path = str(pathlib.Path(vcpkg_installed_raw).resolve())
              print(f"Repair script: Using VCPKG_INSTALLED_DIR_PATH_FOR_CIBW resolved to: {vcpkg_installed_path}")

              add_path_arg = f"{vcpkg_installed_path}\\bin;{vcpkg_installed_path}\\lib"
              pathlib.Path(dest_dir_str).mkdir(parents=True, exist_ok=True)
              delvewheel_cmd_module = [
                  sys.executable, "-m", "delvewheel", "repair",
                  "--add-path", add_path_arg,
                  "-w", dest_dir_str,
                  wheel_file_path_str
              ]
              print(f"Tentativo di riparazione delvewheel con comando: {' '.join(delvewheel_cmd_module)}")
              try:
                  process = subprocess.run(delvewheel_cmd_module, check=True, capture_output=True, text=True, encoding='utf-8')
                  print("Output Delvewheel (python -m):")
                  print(process.stdout)
                  if process.stderr:
                      print("Errori Delvewheel (python -m):")
                      print(process.stderr)
              except subprocess.CalledProcessError as e_retry:
                  print(f"::error::Delvewheel (tramite python -m) fallito con codice {e_retry.returncode}")
                  print(f"Stdout Delvewheel (python -m): {e_retry.stdout}")
                  print(f"Stderr Delvewheel (python -m): {e_retry.stderr}")
                  sys.exit(e_retry.returncode)
              except FileNotFoundError as e_fnf_retry:
                  print(f"::error::Delvewheel (tramite python -m) fallito, eseguibile python non trovato o modulo delvewheel mancante: {e_fnf_retry}")
                  sys.exit(1)
              print(f"Riparazione Delvewheel presumibilmente completata con successo per {wheel_file_path_str}")
          EOF

      - name: Build wheels with cibuildwheel
        uses: pypa/cibuildwheel@v2.19.1
        env:
          # VCPKG_ROOT è impostato da lukka/run-vcpkg.
          # PRIMARY_VCPKG_TRIPLET è impostato da "Determine vcpkg triplet...".
          # VCPKG_INSTALLED_DIR_PATH_FOR_CIBW (default) e LD_LIBRARY_PATH_FOR_CIBW (default) sono impostati da "Install vcpkg packages...".
          # Queste variabili sono disponibili in env e possono essere usate sotto.

          # Passa le mappature dei triplet specifici per Windows
          TRIPLET_MAP_X86_WIN: ${{ matrix.vcpkg_triplet_map_x86 }}
          TRIPLET_MAP_AMD64_WIN: ${{ matrix.vcpkg_triplet_map_amd64 }}
          
          CIBW_ENVIRONMENT_WINDOWS: |
            set "VCPKG_TRIPLET_CURRENT_ARCH="
            if /I "%CIBW_BUILD_ARCHITECTURE%" == "x86" (
              set "VCPKG_TRIPLET_CURRENT_ARCH=%TRIPLET_MAP_X86_WIN%"
            )
            if /I "%CIBW_BUILD_ARCHITECTURE%" == "AMD64" (
              set "VCPKG_TRIPLET_CURRENT_ARCH=%TRIPLET_MAP_AMD64_WIN%"
            )
            if "%VCPKG_TRIPLET_CURRENT_ARCH%" == "" (
              echo "::error::[CIBW_ENVIRONMENT_WINDOWS] Impossibile determinare VCPKG_TRIPLET_CURRENT_ARCH per CIBW_BUILD_ARCHITECTURE: %CIBW_BUILD_ARCHITECTURE%"
              exit /B 1
            )
            set "VCPKG_INSTALLED_DIR_ARCH_SPECIFIC=%VCPKG_ROOT%\installed\%VCPKG_TRIPLET_CURRENT_ARCH%"
            set "CMAKE_PREFIX_PATH=%VCPKG_INSTALLED_DIR_ARCH_SPECIFIC%"
            set "PATH=%VCPKG_INSTALLED_DIR_ARCH_SPECIFIC%\bin;%VCPKG_INSTALLED_DIR_ARCH_SPECIFIC%\tools\%VCPKG_TRIPLET_CURRENT_ARCH%\bin;%PATH%"
            set "VCPKG_INSTALLED_DIR_PATH_FOR_CIBW=%VCPKG_INSTALLED_DIR_ARCH_SPECIFIC%"
            echo [CIBW_ENVIRONMENT_WINDOWS] CIBW_BUILD_ARCHITECTURE: %CIBW_BUILD_ARCHITECTURE%
            echo [CIBW_ENVIRONMENT_WINDOWS] VCPKG_TRIPLET_CURRENT_ARCH: %VCPKG_TRIPLET_CURRENT_ARCH%
            echo [CIBW_ENVIRONMENT_WINDOWS] VCPKG_INSTALLED_DIR_PATH_FOR_CIBW (per repair script) impostato a: %VCPKG_INSTALLED_DIR_PATH_FOR_CIBW%
            echo [CIBW_ENVIRONMENT_WINDOWS] CMAKE_PREFIX_PATH (per build) impostato a: %CMAKE_PREFIX_PATH%
          CIBW_ENVIRONMENT_LINUX: >-
            CMAKE_PREFIX_PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}
            LD_LIBRARY_PATH=${{ env.LD_LIBRARY_PATH_FOR_CIBW }}${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}
            PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/bin:${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/tools/${{ env.PRIMARY_VCPKG_TRIPLET }}/bin:$PATH
          CIBW_ENVIRONMENT_MACOS: >-
            CMAKE_PREFIX_PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}
            DYLD_LIBRARY_PATH=${{ env.LD_LIBRARY_PATH_FOR_CIBW }}${DYLD_LIBRARY_PATH:+:$DYLD_LIBRARY_PATH}
            PATH=${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/bin:${{ env.VCPKG_INSTALLED_DIR_PATH_FOR_CIBW }}/tools/${{ env.PRIMARY_VCPKG_TRIPLET }}/bin:$PATH

          CIBW_BUILD: "cp38-* cp39-* cp310-* cp311-* cp312-* cp313-*"
          CIBW_ARCHS_WINDOWS: ${{ matrix.cibw_archs }}
          CIBW_ARCHS_LINUX: ${{ matrix.cibw_archs }}
          CIBW_ARCHS_MACOS: ${{ matrix.cibw_archs }}

          CIBW_MANYLINUX_X86_64_IMAGE: manylinux_2_28
          CIBW_MANYLINUX_AARCH64_IMAGE: manylinux_2_28
          CIBW_BEFORE_ALL_LINUX: >-
            yum install -y openssl-devel &&
            rm -rf /var/cache/yum
          
          CIBW_BEFORE_BUILD_WINDOWS: "echo In CIBW_BEFORE_BUILD_WINDOWS. CIBW_BUILD_ARCHITECTURE is %CIBW_BUILD_ARCHITECTURE%. Current PATH is %PATH%. Current INCLUDE is %INCLUDE%. Current LIB is %LIB%. VCPKG_INSTALLED_DIR_PATH_FOR_CIBW (from CIBW_ENVIRONMENT) is %VCPKG_INSTALLED_DIR_PATH_FOR_CIBW%."

          CIBW_BUILD_VERBOSITY: 3

          CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: "python .github/workflows/repair_wheel_windows.py {wheel} {dest_dir}"
          CIBW_PIP_PACKAGES_WINDOWS: delvewheel

          CIBW_PIP_PACKAGES_MACOS: delocate

      - name: Upload Python Wheel Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-wheels-${{ matrix.os }}-${{ matrix.arch_label }}
          path: ./wheelhouse/*.whl

  build_sdist:
    name: Build Python sdist
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python (for sdist)
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Run C/C++ code vendoring script
        run: python synthizer-c/vendor.py synthizer-vendored

      - name: Install Python build dependencies (sdist)
        run: |
          python -m pip install --upgrade pip build

      - name: Build Python sdist
        run: python -m build --sdist

      - name: Upload Python sdist Artifact
        uses: actions/upload-artifact@v4
        with:
          name: python-sdist
          path: dist/*.tar.gz

  deploy_pypi:
    name: Deploy to PyPI
    if: startsWith(github.ref, 'refs/tags')
    needs: [build_wheels, build_sdist]
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      id-token: write # Necessario per il trusted publishing di PyPI
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ~/artifacts # Scarica tutti gli artefatti in questa directory

      - name: Set up Python for Twine
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Twine
        run: python -m pip install --upgrade pip twine

      - name: Display downloaded artifacts structure
        run: ls -R ~/artifacts
      
      - name: Upload to PyPI
        run: |
          echo "Listing all wheel and sdist files to be uploaded:"
          find ~/artifacts -name '*.whl' -print -exec echo \;
          find ~/artifacts -name '*.tar.gz' -print -exec echo \;
          python -m twine upload --skip-existing --verbose $(find ~/artifacts -name '*.whl' -o -name '*.tar.gz')